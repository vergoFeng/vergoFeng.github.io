<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vergo的博客</title>
  
  <subtitle>一枚小小Android程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vergofeng.github.io/"/>
  <updated>2018-04-04T01:36:46.898Z</updated>
  <id>https://vergofeng.github.io/</id>
  
  <author>
    <name>Vergo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android工具类</title>
    <link href="https://vergofeng.github.io/2017/12/13/android-utils/"/>
    <id>https://vergofeng.github.io/2017/12/13/android-utils/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2018-04-04T01:36:46.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/IzybjYi.png" alt=""></p><h2><span id="about">About</span></h2><p>Android开发过程中经常使用到各式各样的工具类，这里整理了平常用到的工具类，方便开发使用。<br>github：<a href="https://github.com/vergoFeng/UtilsLibrary" target="_blank" rel="noopener">https://github.com/vergoFeng/UtilsLibrary</a></p><a id="more"></a><h2><span id="gradle">Gradle</span></h2><p>Step 1. 在build.gradle(Project:XXX)文件中增加JitPack仓库依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step 2. 在build.gradle(Module:XXX)文件中增加LUtilsLibrary依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.github.vergoFeng:UtilsLibrary:1.2.1&apos;</span><br></pre></td></tr></table></figure><h2><span id="how-to-use">How to use</span></h2><p>在使用utils下的相关工具，需要进行初始化，在Application中进行初始化：</p><p><code>UtilsInit.init(getApplicationContext());</code></p><p>此类中提供了全局的Context，获取方法：</p><p><code>UtilsInit.getContext();</code></p><h2><span id="api">API</span></h2><ul><li><h3><span id="app相关-apputils">App相关： AppUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAppPackageName : 获取App包名</span><br><span class="line">isInstallApp      : 判断App是否安装</span><br><span class="line">launchApp         : 打开App</span><br></pre></td></tr></table></figure><ul><li><h3><span id="状态栏相关-barutils">状态栏相关： BarUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setStatusBarColor       : 设置状态栏颜色</span><br><span class="line">hideStatusBar           : 隐藏状态栏</span><br><span class="line">getStatusBarHeight      : 获取状态栏高度</span><br><span class="line">setFullScreen           : 设置全屏</span><br><span class="line">setTranslucentStatus    : 设置状态栏透明(api大于19方可使用)</span><br><span class="line">setStatusBarMode        : 设置状态栏黑色字体图标(6.0以上版本)</span><br><span class="line">setStatusBarModeByFlyme : 设置状态栏图标为深色和魅族特定的文字风格</span><br><span class="line">setStatusBarModeByMIUI  : 设置状态栏字体图标为深色，需要MIUIV6以上</span><br></pre></td></tr></table></figure><ul><li><h3><span id="图像操作相关-bitmaputils">图像操作相关： BitmapUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitmap2Bytes : bitmap转byte[]</span><br><span class="line">bytes2Bitmap : byte[]转bitmap</span><br><span class="line">getBitmap    : 获取Bitmap</span><br><span class="line">save         : 保存图片</span><br></pre></td></tr></table></figure><ul><li><h3><span id="尺寸相关densityutils">尺寸相关：DensityUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp2px : dp转px</span><br><span class="line">px2dp : px转dp</span><br><span class="line">sp2px : sp转px</span><br><span class="line">px2sp : px转sp</span><br></pre></td></tr></table></figure><ul><li><h3><span id="设备相关deviceutils">设备相关：DeviceUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getSDKVersionName : 获取设备系统版本号</span><br><span class="line">getSDKVersionCode : 获取设备系统版本码</span><br><span class="line">getManufacturer   : 获取设备厂商</span><br><span class="line">getModel          : 获取设备型号</span><br></pre></td></tr></table></figure><ul><li><h3><span id="判断双击相关doubleclickutils">判断双击相关：DoubleClickUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isDoubleClick : 判断是否双击</span><br><span class="line"></span><br><span class="line">//默认时间间隔500ms</span><br><span class="line">isDoubleClick()</span><br><span class="line">//自定义判断双击的时间间隔，单位ms</span><br><span class="line">isDoubleClick(int doubleTime)</span><br></pre></td></tr></table></figure><ul><li><h3><span id="加密解密相关encryptutils">加密解密相关：EncryptUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">encryptMD5ToString   : MD5加密（16进制密文字符串）</span><br><span class="line">encryptAES2Base64    : 加密后转为Base64编码</span><br><span class="line">encryptAES2HexString : 加密后转为16进制</span><br><span class="line">decryptBase64AES     : 解密Base64编码密文</span><br><span class="line">decryptHexStringAES  : 解密16进制密文</span><br></pre></td></tr></table></figure><ul><li><h3><span id="文件相关fileutils">文件相关：FileUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getFileByPath      : 根据文件路径获取文件</span><br><span class="line">createOrExistsDir  : 判断目录是否存在，不存在则判断是否创建成功</span><br><span class="line">createOrExistsFile : 判断文件是否存在，不存在则判断是否创建成功</span><br><span class="line">isFileExists       : 判断文件是否存在</span><br><span class="line">getDirLength       : 获取目录大小</span><br><span class="line">getFileLength      : 获取文件大小</span><br><span class="line">copyFile           : 复制文件</span><br><span class="line">deleteDir          : 删除目录</span><br><span class="line">deleteFile         : 删除文件</span><br></pre></td></tr></table></figure><ul><li><h3><span id="键盘相关inputmethodutils">键盘相关：InputMethodUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showSoftInput      : 动态显示键盘</span><br><span class="line">hideSoftInput      : 动态隐藏键盘</span><br><span class="line">touchHideSoftInput : 触摸空白区域隐藏</span><br></pre></td></tr></table></figure><ul><li><h3><span id="intent意图相关intentutils">Intent意图相关：IntentUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDialIntent     : 获取跳至拨号界面意图</span><br><span class="line">getCallIntent     : 获取拨打电话意图</span><br><span class="line">getSendSmsIntent  : 获取跳至发送短信界面的意图</span><br><span class="line">getSendMailIntent : 获取跳至发邮件的意图</span><br><span class="line">getCameraIntent   : 获取打开相机拍照的意图</span><br></pre></td></tr></table></figure><ul><li><h3><span id="日志相关jlog">日志相关：JLog</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setLogSwitch     : 设置log总开关，默认为true</span><br><span class="line">setGlobalTag     : 设置log全局标签</span><br><span class="line">setLogHeadSwitch : 设置log头信息开关</span><br><span class="line">setBorderSwitch  : 设置输出日志是否带边框开关</span><br><span class="line">setStackDeep     : 设置log栈深度，默认为1</span><br><span class="line">v                : tag为全局的Verbose日志</span><br><span class="line">vTag             : 自定义tag的Verbose日志</span><br><span class="line">d                : tag为全局的Debug日志</span><br><span class="line">dTag             : 自定义tag的Debug日志</span><br><span class="line">i                : tag为全局的Info日志</span><br><span class="line">iTag             : 自定义tag的Info日志</span><br><span class="line">w                : tag为全局的Warn日志</span><br><span class="line">wTag             : 自定义tag的Warn日志</span><br><span class="line">e                : tag为全局的Error日志</span><br><span class="line">eTag             : 自定义tag的Error日志</span><br><span class="line">a                : tag为全局的Assert日志</span><br><span class="line">aTag             : 自定义tag的Assert日志</span><br><span class="line">json             : log字符串之json</span><br></pre></td></tr></table></figure><ul><li><h3><span id="网络相关networkutils">网络相关：NetworkUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isConnected     : 判断网络是否连接</span><br><span class="line">isWifiConnected : 判断wifi是否连接状态</span><br><span class="line">getNetworkType  : 获取当前网络类型</span><br><span class="line">getIPAddress    : 获取 IP 地址</span><br></pre></td></tr></table></figure><ul><li><h3><span id="手机系统相关osutils">手机系统相关：OsUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isMIUI  : 判断手机系统是否是小米MIUI</span><br><span class="line">isFlyme : 判断手机系统是否是魅族Flyme</span><br></pre></td></tr></table></figure><ul><li><h3><span id="手机相关phoneutils">手机相关：PhoneUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPhoneIMEI       : 获取手机IMEI码</span><br><span class="line">getSimOperatorCode : 获取Sim卡运营商名称code值</span><br></pre></td></tr></table></figure><ul><li><h3><span id="屏幕相关screenutils">屏幕相关：ScreenUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getScreenWidth  : 获取屏幕的宽度</span><br><span class="line">getScreenHeight : 获取屏幕的高度</span><br></pre></td></tr></table></figure><ul><li><h3><span id="sd卡相关sdcardutils">SD卡相关：SDCardUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isSDCardEnable      : 判断SD卡是否可用</span><br><span class="line">getCacheDirectory   : 获取应用专属缓存目录，返回File</span><br><span class="line">getCachePath        : 获取应用专属缓存目录，返回String</span><br><span class="line">getStorageDirectory : 获取SD卡的根目录，返回File</span><br><span class="line">getStoragePath      : 获取SD卡的根目录，返回String</span><br></pre></td></tr></table></figure><ul><li><h3><span id="sharedpreferences相关sputils">SharedPreferences相关：SPUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">init       : 获取SPUtils对象</span><br><span class="line">put        : SP中写入数据</span><br><span class="line">putString  : SP中写入String</span><br><span class="line">putInt     : SP中写入int</span><br><span class="line">putLong    : SP中写入long</span><br><span class="line">putFloat   : SP中写入float</span><br><span class="line">putBoolean : SP中写入boolean</span><br><span class="line">get        : SP中读取数据</span><br><span class="line">getString  : SP中读取String</span><br><span class="line">getInt     : SP中读取int</span><br><span class="line">getLong    : SP中读取long</span><br><span class="line">getFloat   : SP中读取float</span><br><span class="line">getBoolean : SP中读取boolean</span><br><span class="line">getAll     : SP中获取所有键值对</span><br><span class="line">contains   : SP中是否存在该key</span><br><span class="line">remove     : SP中移除该key</span><br><span class="line">clear      : SP中清除所有数据</span><br></pre></td></tr></table></figure><ul><li><h3><span id="字符串相关stringutils">字符串相关：StringUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isEmpty         : 判断字符串是否为null或长度为0</span><br><span class="line">isTrimEmpty     : 判断字符串是否为null或全为空格（v1.1.1版本已废弃）</span><br><span class="line">isSpace         : 判断字符串是否为null或全为空白字符</span><br><span class="line">isMobileSimple  : 验证手机号（简单）</span><br><span class="line">isMobileSimple  : 验证手机号（精确）</span><br><span class="line">isIDCard        : 验证身份证号码（18位）</span><br><span class="line">isEmail         : 验证邮箱</span><br><span class="line">containsChinese : 判断字符串是否包含中文</span><br><span class="line">containsEmoji   : 判断字符串是否包含emoji表情</span><br></pre></td></tr></table></figure><ul><li><h3><span id="时间相关timeutils">时间相关：TimeUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">formatDate1  : 获取与当前时间的差</span><br><span class="line">formatDate2  : 日期转换格式：yyyy-MM-dd</span><br><span class="line">formatDate3  : 日期转换格式：yyyy年MM月dd日</span><br><span class="line">formatDate4  : 日期转换格式：yyyy-MM-dd HH:mm:ss</span><br><span class="line">stringToDate : string类型转换为date类型</span><br><span class="line">stringToLong : string类型转换为long类型</span><br><span class="line">dateToLong   : date类型转换为long类型</span><br></pre></td></tr></table></figure><ul><li><h3><span id="吐司相关toastutils">吐司相关：ToastUtils</span></h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">showShort     : 显示短时吐司</span><br><span class="line">showShortSafe : 安全地显示短时吐司</span><br><span class="line">showLong      : 显示长时吐司</span><br><span class="line">showLongSafe  : 安全地显示长时吐司</span><br><span class="line">cancel        : 取消吐司显示</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/IzybjYi.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;About&quot;&gt;&lt;a href=&quot;#About&quot; class=&quot;headerlink&quot; title=&quot;About&quot;&gt;&lt;/a&gt;About&lt;/h2&gt;&lt;p&gt;Android开发过程中经常使用到各式各样的工具类，这里整理了平常用到的工具类，方便开发使用。&lt;br&gt;github：&lt;a href=&quot;https://github.com/vergoFeng/UtilsLibrary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/vergoFeng/UtilsLibrary&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义View之绘制1-1</title>
    <link href="https://vergofeng.github.io/2017/11/04/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%BB%98%E5%88%B61-1/"/>
    <id>https://vergofeng.github.io/2017/11/04/自定义View之绘制1-1/</id>
    <published>2017-11-03T16:00:00.000Z</published>
    <updated>2017-12-18T10:37:15.928Z</updated>
    
    <content type="html"><![CDATA[<p>自定义绘制的方法是重写绘制方法，最常用的是onDraw()，绘制的关键是Canvas的使用。</p><h2><span id="自定义绘制知识的4个级别">自定义绘制知识的4个级别</span></h2><ul><li>Canvas 的 drawXXX() 系列方法</li><li>Paint 的完全攻略</li><li>Canvas 对绘制的辅助——范围裁切和几何变换。</li><li>可以使用不同的绘制方法来控制遮盖关系。</li></ul><a id="more"></a><h2><span id="canvasdrawxxx系列方法">Canvas.drawXXX()系列方法</span></h2><h3><span id="绘制颜色drawcolorint-color">绘制颜色<br>drawColor(int color)</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawColor(Color.Yellow);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/HKXY84s.png" alt=""></p><p>类似的方法还有 drawRGB(int r, int g, int b) 和 drawARGB(int a, int r, int g, int b) ，它们和  drawColor(color) 只是使用方式不同，作用都是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRGB(100, 200, 100);  </span><br><span class="line">canvas.drawARGB(100, 100, 200, 100);</span><br></pre></td></tr></table></figure></p><p>这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。</p><h3><span id="绘制圆形drawcirclefloat-centerx-float-centery-float-radius-paint-paint">绘制圆形<br>drawCircle(float centerX, float centerY, float radius, Paint paint)</span></h3><p>前两个参数 centerX centerY 是圆心的坐标，第三个参数 radius 是圆的半径，单位都是像素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawCircle(250, 250, 200, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/8K5t0Tz.png" alt=""></p><h3><span id="绘制矩形drawrectfloat-left-float-top-float-right-float-bottom-paint-paint">绘制矩形<br>drawRect(float left, float top, float right, float bottom, Paint paint)</span></h3><p>确定确定一个矩形最少需要四个数据，就是对角线的两个点的坐标值，这里一般采用左上角和右下角的两个点的坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRect(100, 100, 800, 400, mPaint);</span><br><span class="line">canvas.drawRect(100, 500, 500, 900, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/UnQJLqQ.png" alt=""></p><p>另外，它还有两个重载方法 drawRect(Rect rect, Paint paint) 和 drawRect(RectF rectf, Paint paint)，让你可以直接填写 RectF 或 Rect 对象来绘制矩形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rect rect = new Rect(100,100,800,400);</span><br><span class="line">canvas.drawRect(rect, mPaint);</span><br><span class="line"></span><br><span class="line">RectF rectF = new RectF(100,100,800,400);</span><br><span class="line">canvas.drawRect(rectF, mPaint);</span><br></pre></td></tr></table></figure></p><p>ps：Rect，RectF两者最大的区别就是精度不同，Rect是int(整形)的，而RectF是float(单精度浮点型)的</p><h3><span id="绘制点drawpointfloat-x-float-y-paint-paint">绘制点<br>drawPoint(float x, float y, Paint paint)</span></h3><p>x 和 y 是点的坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPaint.setStrokeWidth(20);</span><br><span class="line">canvas.drawPoint(200, 200, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/GPszSPw.png" alt=""></p><h3><span id="绘制一组点drawpointsfloat-pts-int-offset-int-count-paint-paint-drawpointsfloat-pts-paint-paint">绘制一组点<br>drawPoints(float[] pts, int offset, int count, Paint paint) <br> drawPoints(float[] pts, Paint paint)</span></h3><p>pts 这个数组是点的坐标，每两个成一对；offset 表示跳过数组的前几个数再开始记坐标；count 表示一共要绘制几个点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mPaint.setStrokeWidth(20);</span><br><span class="line"></span><br><span class="line">float[] points = &#123;0, 0, 50, 50, 50, 100, 100, 50, 100, 100, 150, 50, 150, 100&#125;;</span><br><span class="line">/*</span><br><span class="line"> * 跳过两个数，即前两个 0</span><br><span class="line"> * 一共绘制 8 个数（4 个点）</span><br><span class="line"> * 即绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)</span><br><span class="line"> */</span><br><span class="line">canvas.drawPoints(points, 2, 8, mPaint);</span><br><span class="line"></span><br><span class="line">//绘制三个点</span><br><span class="line">canvas.drawPoints(new float[]&#123;</span><br><span class="line">        200, 200,</span><br><span class="line">        300, 200,</span><br><span class="line">        400, 200</span><br><span class="line">&#125;, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/oIkg4xG.png" alt=""></p><h3><span id="绘制椭圆drawovalfloat-left-float-top-float-right-float-bottom-paint-paint">绘制椭圆<br>drawOval(float left, float top, float right, float bottom, Paint paint)</span></h3><p>绘制椭圆实际上就是绘制一个矩形的内切图形，所以参数和绘制矩形参数一致。<br>另外，它还有一个重载方法 drawOval(RectF rect, Paint paint)，让你可以直接填写 RectF 来绘制椭圆。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRect(100, 100, 800, 400, mPaint);</span><br><span class="line"></span><br><span class="line">RectF rectF = new RectF(100,100,800,400);</span><br><span class="line">canvas.drawOval(rectF, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/6fo90HS.png" alt=""></p><p>注意：drawOval(float left, float top, float right, float bottom, Paint paint)方法是在api21的时候增加的，所以使用的时候需要注意minSdkVersion的值，使用该方法的时候要判断版本，或者直接使用drawOval(RectF rect, Paint paint)方法。</p><h3><span id="绘制直线drawlinefloat-startx-float-starty-float-stopx-float-stopy-paint-paint">绘制直线<br>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</span></h3><p>startX, startY, stopX, stopY 分别是线的起点和终点坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPaint.setStrokeWidth(10);</span><br><span class="line">canvas.drawLine(200, 200, 800, 500, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/rxut3OS.png" alt=""></p><h3><span id="绘制一组直线drawlinesfloat-pts-int-offset-int-count-paint-paint-drawlinesfloat-pts-paint-paint">绘制一组直线<br>drawLines(float[] pts, int offset, int count, Paint paint) <br> drawLines(float[] pts, Paint paint)</span></h3><p>参数的含义和绘制点的参数含义一样，可参考绘制点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float[] points = &#123;200, 200, 200, 800, 200, 500, 500, 500, 500, 200, 500, 800&#125;;</span><br><span class="line">canvas.drawLines(points, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/Q6zgvcW.png" alt=""></p><h3><span id="绘制圆角矩形drawroundrectfloat-left-float-top-float-right-float-bottom-float-rx-float-ry-paint-paintdrawroundrectrectf-rect-float-rx-float-ry-paint-paint">绘制圆角矩形<br>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)<br>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</span></h3><p>left, top, right, bottom 是左上角和右下角的两个点的坐标, rx 和 ry 是圆角的横向半径和纵向半径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//api&gt;=21</span><br><span class="line">canvas.drawRoundRect(100, 100, 700, 400, 50, 50, mPaint);</span><br><span class="line"></span><br><span class="line">RectF rectF = new RectF(100, 100, 700, 400);</span><br><span class="line">canvas.drawRoundRect(rectF, 50, 50, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/Sro7zxo.png" alt=""></p><p>和绘制椭圆一样，第一个drawRoundRect方法是在api21的时候增加的，所以使用的时候需要注意minSdkVersion的值，使用该方法的时候要判断版本，或者直接使用第二个drawRoundRect方法。</p><p>有一点值得注意的就是，这里的圆角实际上不是一个正圆的圆弧，而是椭圆的圆弧，rx 和 ry两个参数实际上是椭圆的两个半径，所以当rx为宽度的一半，ry为高度的一半时，就会发现绘制出来的刚好是一个椭圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RectF rectF = new RectF(100, 100, 700, 400);</span><br><span class="line">canvas.drawRoundRect(rectF, 300, 150, mPaint);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/MwOu676.png" alt=""></p><p>所以在当rx大于宽度的一半，ry大于高度的一半时，实际上是无法计算出圆弧的，所以drawRoundRect对大于该数值的参数进行了限制(修正)，凡是大于一半的参数均按照一半来处理，即绘制出来的均是椭圆。</p><h3><span id="绘制弧形或扇形drawarcfloat-left-float-top-float-right-float-bottom-float-startangle-float-sweepangle-boolean-usecenter-paint-paintdrawarcrectf-oval-float-startangle-float-sweepangle-boolean-usecenter-paint-paint">绘制弧形或扇形<br>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)<br>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</span></h3><p>drawArc() 是使用一个椭圆来描述弧形的。<br>left, top, right, bottom 描述的是这个弧形所在的椭圆；<br>startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度）；<br>sweepAngle 是弧形划过的角度；<br>useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    canvas.drawArc(200, 200, 800, 500, -110, 100, true, mPaint); // 绘制扇形</span><br><span class="line">    canvas.drawArc(200, 200, 800, 500, 20, 140, false, mPaint); // 绘制弧形</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    RectF rectF = new RectF(200, 200, 800, 500);</span><br><span class="line">    canvas.drawArc(rectF, -110, 100, true, mPaint);</span><br><span class="line">    canvas.drawArc(rectF, 20, 140, false, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/HXP6T87.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义绘制的方法是重写绘制方法，最常用的是onDraw()，绘制的关键是Canvas的使用。&lt;/p&gt;
&lt;h2 id=&quot;自定义绘制知识的4个级别&quot;&gt;&lt;a href=&quot;#自定义绘制知识的4个级别&quot; class=&quot;headerlink&quot; title=&quot;自定义绘制知识的4个级别&quot;&gt;&lt;/a&gt;自定义绘制知识的4个级别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Canvas 的 drawXXX() 系列方法&lt;/li&gt;
&lt;li&gt;Paint 的完全攻略&lt;/li&gt;
&lt;li&gt;Canvas 对绘制的辅助——范围裁切和几何变换。&lt;/li&gt;
&lt;li&gt;可以使用不同的绘制方法来控制遮盖关系。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="View" scheme="https://vergofeng.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Glide使用4 自定义模板</title>
    <link href="https://vergofeng.github.io/2017/10/14/Glide-v4%E4%BD%BF%E7%94%A84/"/>
    <id>https://vergofeng.github.io/2017/10/14/Glide-v4使用4/</id>
    <published>2017-10-14T02:03:00.000Z</published>
    <updated>2018-01-10T09:11:57.783Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="基本用法">基本用法</span></h2><p>自定义模块功能可以将更改Glide配置，替换Glide组件等操作独立出来，可以轻松地对Glide的各种配置进行自定义，并且和Glide的图片加载逻辑没有任何交集，实现了低耦合。</p><p>自定义很简单，定义一个模块类继承 AppGlideModule，如下所示</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class MyGlideMoulde extends AppGlideModule &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line">        super.applyOptions(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerComponents(Context context, Glide glide, Registry registry) &#123;</span><br><span class="line">        super.registerComponents(context, glide, registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，定义的模块类需要添加@GlideModule注解。</p><p>其中重写了两个方法，其中<code>applyOptions()</code>方法用来更改Glide配置，<code>registerComponents()</code>方法用来替换Glide组件。</p><p>Glide自定义模块的功能就是这样，后面只需要在applyOptions()和registerComponents()这两个方法中加入具体的逻辑，就能实现更改Glide配置或者替换Glide组件的功能。</p><h3><span id="更改glide配置">更改Glide配置</span></h3><p>想要更改Glide配置，只需要在 applyOptions() 方法中提前将Glide的配置项进行初始化就可以了。常用的Glide配置有</p><ul><li><p>setMemoryCache() </p><p>用于配置Glide的内存缓存策略，默认配置是LruResourceCache。</p></li><li><p>setBitmapPool() </p><p>用于配置Glide的Bitmap缓存池，默认配置是LruBitmapPool。</p></li><li><p>setDiskCache() </p><p>用于配置Glide的硬盘缓存策略，默认配置是InternalCacheDiskCacheFactory。</p></li><li><p>setDecodeFormat() </p><p>用于配置Glide加载图片的解码模式，默认配置是RGB_565。</p></li></ul><h5><span id="setmemorycache">setMemoryCache()</span></h5><p>默认情况下，Glide使用 LruResourceCache ，这是 MemoryCache 接口的一个缺省实现，使用固定大小的内存和 LRU 算法。LruResourceCache 的大小由 Glide 的 MemorySizeCalculator 类来决定，这个类主要关注设备的内存类型，设备 RAM 大小，以及屏幕分辨率。</p><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第1种：通过配置 MemorySizeCalculator</span><br><span class="line">MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)</span><br><span class="line">        .setMemoryCacheScreens(2)</span><br><span class="line">        .build();</span><br><span class="line">builder.setMemoryCache(new LruResourceCache(calculator.getMemoryCacheSize()));</span><br><span class="line"></span><br><span class="line">//第2种：直接覆写缓存大小</span><br><span class="line">int memoryCacheSizeBytes = 20 * 1024 * 1024;</span><br><span class="line">builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));</span><br></pre></td></tr></table></figure><h5><span id="setbitmappool">setBitmapPool()</span></h5><p>Glide 使用 LruBitmapPool 作为默认的 BitmapPool 。LruBitmapPool 是一个内存中的固定大小的 BitmapPool，使用 LRU 算法清理。默认大小基于设备的分辨率和密度，同时也考虑内存类和 isLowRamDevice 的返回值。具体的计算通过 Glide 的 MemorySizeCalculator 来完成，与 Glide 的 MemoryCache 的大小检测方法相似。</p><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第1种：通过配置 MemorySizeCalculator</span><br><span class="line">MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)</span><br><span class="line">        .setBitmapPoolScreens(3)</span><br><span class="line">        .build();</span><br><span class="line">builder.setBitmapPool(new LruBitmapPool(calculator.getBitmapPoolSize()));</span><br><span class="line"></span><br><span class="line">//第2种：直接覆写Bitmap缓存大小</span><br><span class="line">int bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mb</span><br><span class="line">builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));</span><br></pre></td></tr></table></figure><h5><span id="setdiskcache">setDiskCache()</span></h5><p>Glide默认的硬盘缓存策略使用的是InternalCacheDiskCacheFactory，这种缓存会将所有Glide加载的图片都存储到当前应用的私有目录下，默认磁盘大小为 250 MB 。</p><p>Glide内置了一个ExternalCacheDiskCacheFactory，可以允许将加载的图片都缓存到SD卡。</p><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int diskCacheSizeBytes = 500 * 1024 * 1024;</span><br><span class="line">builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, diskCacheSizeBytes));</span><br></pre></td></tr></table></figure><p>这时候再去加载图片，图片缓存就会保存到磁盘中。</p><h5><span id="setdecodeformat">setDecodeFormat()</span></h5><p>Glide加载图片的默认格式是RGB_565，如果希望图片展现效果最佳，需要设置为ARGB_8888，则就通过 setDecodeFormat() 方法来设置。</p><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);</span><br></pre></td></tr></table></figure><h3><span id="替换glide组件">替换Glide组件</span></h3><p>详情去官方文档中 <a href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html" target="_blank" rel="noopener">配置</a> 学习用法。</p><p>Glide官方给我们提供了非常简便的HTTP组件替换方式。并且除了支持OkHttp3之外，还支持OkHttp2和Volley。</p><p>目前主流的HTTP框架是okhttp3，引用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//HTTP组件替换为okhttp3</span><br><span class="line">compile &apos;com.github.bumptech.glide:okhttp3-integration:4.0.0&apos;</span><br></pre></td></tr></table></figure><h3><span id="generated-api">Generated API</span></h3><p>Glide v4 使用注解处理器 (Annotation Processor) 来生成出一个 API，在 Application 模块中可使用该流式 API 一次性调用到 RequestBuilder， RequestOptions 和集成库中所有的选项。</p><p>简单来说就是，在Glide v4中，通过自定义一个模块，添加@GlideModule注解，重新编译后，提供了一套和Glide v3一模一样的流式API接口。</p><p>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(this) </span><br><span class="line">        .load(url) </span><br><span class="line">        .placeholder(R.drawable.loading) </span><br><span class="line">        .error(R.drawable.error) </span><br><span class="line">        .skipMemoryCache(true) </span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE) </span><br><span class="line">        .override(Target.SIZE_ORIGINAL) </span><br><span class="line">        .circleCrop() </span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure><p>如果有用过Glide v3的需要注意下，v3中的Glide关键字要替换成GlideApp关键字。</p><p>Generated API所能做到的并不只是这些而已，它还可以对现有的API进行扩展，定制出任何属于你自己的API，需要借助 @GlideExtension 。</p><p>@GlideExtension 注解用于标识一个扩展 Glide API 的类，被 @GlideExtention 注解的类有两种扩展方式：</p><ul><li>@GlideOption - 为 RequestOptions 添加一个自定义的选项。</li><li>@GlideType - 添加对新的资源类型的支持(GIF，SVG 等等)。</li></ul><h5><span id="glideoption">@GlideOption</span></h5><p>用 @GlideOption 注解的静态方法用于扩展 RequestOptions 。GlideOption 可以：</p><p>1、定义一个在 Application 模块中频繁使用的选项集合。<br>2、创建新的选项，通常与 Glide 的 Option 类一起使用。</p><p>要定义一个选项集合，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GlideExtension</span><br><span class="line">public class MyGlideExtension &#123;</span><br><span class="line">    private static final int MINI_THUMB_SIZE = 100;</span><br><span class="line"></span><br><span class="line">    private MyGlideExtension() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @GlideOption</span><br><span class="line">    public static void miniThumb(RequestOptions options) &#123;</span><br><span class="line">        options.fitCenter().override(MINI_THUMB_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译之后，在build/generated/source/apt/debug 下app对应包名下 GlideOptions 中生成一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class GlideOptions extends RequestOptions &#123;</span><br><span class="line">    ......</span><br><span class="line">    /**</span><br><span class="line">     * @see MyGlideExtension#miniThumb(RequestOptions)</span><br><span class="line">     */</span><br><span class="line">    public GlideOptions miniThumb() &#123;</span><br><span class="line">        MyGlideExtension.miniThumb(this);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后你就可以使用生成的 GlideApp 类调用自定义方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">   .miniThumb()</span><br><span class="line">   .into(imageView);</span><br></pre></td></tr></table></figure><p>使用 @GlideOption 标记的方法应该为静态方法，并且返回值为空，可以为方法任意添加参数，但要保证第一个参数为 RequestOptions。请注意，这些生成的方法在一般的 Glide 和 RequestOptions 类里不可用。</p><h5><span id="glidetype">@GlideType</span></h5><p>被 @GlideType 注解的静态方法用于扩展 RequestManager。被 @GlideType 注解的方法允许你添加对新的资源类型的支持，包括指定默认选项。</p><p>参考官方的例子，简单列举下用法，例如，为添加对 GIF 的支持，你可以添加一个被 @GlideType 注解的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GlideExtension</span><br><span class="line">public class MyAppExtension &#123;</span><br><span class="line">  private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();</span><br><span class="line"></span><br><span class="line">  @GlideType(GifDrawable.class)</span><br><span class="line">  public static void asGif(RequestBuilder&lt;GifDrawable&gt; requestBuilder) &#123;</span><br><span class="line">    requestBuilder</span><br><span class="line">      .transition(new DrawableTransitionOptions())</span><br><span class="line">      .apply(DECODE_TYPE_GIF);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译之后，在build/generated/source/apt/debug 下app对应包名下会生成一个包含对应方法的 RequestManager ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class GlideRequests extends RequesetManager &#123;</span><br><span class="line"></span><br><span class="line">  public RequestBuilder&lt;GifDrawable&gt; asGif() &#123;</span><br><span class="line">    RequestBuilder&lt;GifDrawable&gt; builder = as(GifDrawable.class);</span><br><span class="line">    MyAppExtension.asGif(builder);</span><br><span class="line">    return builder;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后你可以使用生成的 GlideApp 类调用你的自定义类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(fragment)</span><br><span class="line">  .asGif()</span><br><span class="line">  .load(url)</span><br><span class="line">  .into(imageView);</span><br></pre></td></tr></table></figure><p>被 @GlideType 标记的方法必须使用 RequestBuilder<t> 作为其第一个参数，这里的泛型 <t> 对应 @GlideType 注解中传入的类。该方法应为静态方法，且返回值为空。方法必须定义在一个被 @GlideExtension 注解标记的类中。</t></t></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;自定义模块功能可以将更改Glide配置，替换Glide组件等操作独立出来，可以轻松地对Glide的各种配置进行自定义，并且和Glide的图片加载逻辑没有任何交集，实现了低耦合。&lt;/p&gt;
&lt;p&gt;自定义很简单，定义一个模块类继承 AppGlideModule，如下所示&lt;/p&gt;
    
    </summary>
    
    
      <category term="Glide" scheme="https://vergofeng.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Glide使用3 图片变换</title>
    <link href="https://vergofeng.github.io/2017/10/09/Glide-v4%E4%BD%BF%E7%94%A83/"/>
    <id>https://vergofeng.github.io/2017/10/09/Glide-v4使用3/</id>
    <published>2017-10-09T08:21:20.000Z</published>
    <updated>2018-01-04T06:59:44.052Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="关于图片变换">关于图片变换</span></h2><p>图片变换的意思就是说，Glide从加载了原始图片到最终展示给用户之前，又进行了一些变换处理，从而能够实现一些更加丰富的图片效果，如图片圆角化、圆形化、模糊化等等。</p><h2><span id="基本用法">基本用法</span></h2><p>只需要在RequestOptions中串接transform()方法，并将想要执行的图片变换操作作为参数传入transform()方法即可。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .transform(...); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p>Glide 提供了几种内置的变换，可以直接使用，包括：</p><ul><li>CenterCrop</li><li>FitCenter</li><li>CircleCrop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .centerCrop(); </span><br><span class="line"></span><br><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .fitCenter(); </span><br><span class="line"></span><br><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .circleCrop();</span><br></pre></td></tr></table></figure><p>这些内置的变换API其实是Glide对transform()方法进行了一层封装而已，源码中仍然还是借助transform()方法来实现。</p><p>以circleCrop()为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://img4.imgtn.bdimg.com/it/u=2373086219,3296002021&amp;fm=214&amp;gp=0.jpg&quot;; </span><br><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .circleCrop(); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p>效果如下</p><center><br><img src="/assets/imgs/glide_08.gif" alt=""><br></center><h2><span id="更多用法">更多用法</span></h2><h3><span id="多重变换">多重变换</span></h3><p>默认情况下，每个 transform() 调用，或任何特定转换方法(fitCenter(), centerCrop(), circleCrop())的调用都会替换掉之前的变换。</p><p>如果你想在单次加载中应用多个变换，需要使用 MultiTransformation 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .transform(new MultiTransformation&lt;&gt;(new CenterCrop(), new CircleCrop()));</span><br></pre></td></tr></table></figure><p>效果如下</p><center><br><img src="/assets/imgs/glide_09.gif" alt=""><br></center><h3><span id="定制变换">定制变换</span></h3><p>除了使用内置的图片变换操作，完全可以自己定制一个图片变换，包括圆角化、圆形化、黑白化、模糊化等等。</p><p>这里暂时介绍一个开源库 glide-transformations。它实现了很多通用的图片变换效果，如裁剪变换、颜色变换、模糊变换等等，可以非常轻松地进行各种各样的图片变换。</p><p>glide-transformations的项目主页地址是 :</p><p><a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">https://github.com/wasabeef/glide-transformations</a></p><p>在build.gradle(Moudle: xxx)添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.wasabeef:glide-transformations:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以设置transform，以进行模糊化处理为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://img1.3lian.com/2015/a1/91/d/240.jpg&quot;;</span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .transform(new BlurTransformation(25));</span><br><span class="line">Glide.with(this).load(url)</span><br><span class="line">        .apply(options)</span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure><p>效果如下</p><center><br><img src="/assets/imgs/glide_10.gif" alt=""><br></center><p>同样可以设置多重变换，以进行模糊化处理和黑白化处理为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://img1.3lian.com/2015/a1/91/d/240.jpg&quot;;</span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .transform(new MultiTransformation&lt;&gt;(new BlurTransformation(), new GrayscaleTransformation()));</span><br><span class="line">Glide.with(this).load(url)</span><br><span class="line">        .apply(options)</span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure><p>效果如下</p><center><br><img src="/assets/imgs/glide_11.gif" alt=""><br></center><p>这只是glide-transformations库的一小部分功能而已，更多的图片变换效果可以到它的GitHub项目主页去学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于图片变换&quot;&gt;&lt;a href=&quot;#关于图片变换&quot; class=&quot;headerlink&quot; title=&quot;关于图片变换&quot;&gt;&lt;/a&gt;关于图片变换&lt;/h2&gt;&lt;p&gt;图片变换的意思就是说，Glide从加载了原始图片到最终展示给用户之前，又进行了一些变换处理，从而能够实现一些更加丰富的图片效果，如图片圆角化、圆形化、模糊化等等。&lt;/p&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;只需要在RequestOptions中串接transform()方法，并将想要执行的图片变换操作作为参数传入transform()方法即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Glide" scheme="https://vergofeng.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Glide使用2 回调与监听</title>
    <link href="https://vergofeng.github.io/2017/09/27/Glide-v4%E4%BD%BF%E7%94%A82/"/>
    <id>https://vergofeng.github.io/2017/09/27/Glide-v4使用2/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2018-01-03T07:45:35.980Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="回调">回调</span></h2><h3><span id="关于target">关于Target</span></h3><p>在Glide中，Target 是介于请求和请求者之间的中介者的角色。Target 负责展示占位符，加载资源，并为每个请求决定合适的尺寸。被使用得最频繁的是 ImageViewTargets ，它用于在 ImageView 上展示占位符、Drawable 和 Bitmap 。用户还可以实现自己的 Target ，或者从任何可用的基类派生子类。</p><a id="more"></a><h3><span id="into">into()</span></h3><p>之前使用Glide的时候，into()方法中都是传ImageView，查看源码可以了解到into()还有一个接收Target参数的重载方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(@NonNull Y target) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实传入ImageView，Glide内部也会自动构建一个Target对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">    ......</span><br><span class="line">    return into(context.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buildImageViewTarget</code>方法就是用来构建Target对象的。</p><p>Glide中Target的继承结构图：</p><center><br><img src="/assets/imgs/glide_target.png" alt=""><br></center><p>Target的继承结构还是相当复杂的，实现Target接口的子类非常多。这些大多数都是Glide已经实现好的具备完整功能的Target子类，如果要进行自定义的话，通常只需要在两种Target的基础上去自定义就可以了，一种是SimpleTarget，一种是ViewTarget。</p><h3><span id="simpletarget">SimpleTarget</span></h3><p>它是一种极为简单的Target，我们使用它可以将Glide加载出来的图片对象获取到，而不是像之前那样只能将图片在ImageView上显示出来。</p><p>SimpleTarget的用法示例，这里将获得到的加载图片的对象，进行着色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleTarget&lt;Drawable&gt; simpleTarget = new SimpleTarget&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(Drawable resource, Transition&lt;? super Drawable&gt; transition) &#123;</span><br><span class="line">        Drawable drawableUp= DrawableCompat.wrap(resource);</span><br><span class="line">        DrawableCompat.setTint(drawableUp, Color.BLUE);</span><br><span class="line">        imageView.setImageDrawable(drawableUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(R.mipmap.ic_launcher_round)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(simpleTarget);</span><br></pre></td></tr></table></figure><center><br><img src="/assets/imgs/glide_05.png" alt=""><br></center><h3><span id="viewtarget">ViewTarget</span></h3><p>跟踪<code>buildImageViewTarget</code>方法，可以看出Glide在内部自动帮我们创建成</p><center><br><img src="/assets/imgs/glide_buildtarget.png" alt=""><br></center><p>从上面继承机构图中可以看出，BitmapImageViewTarget和DrawableImageViewTarget就是ViewTarget的子类。只不过它们限定只能作用在ImageView上，而ViewTarget的功能更加广泛，它可以作用在任意的View上。</p><p>举个例子看下基本用法：</p><p>1、首先自定义一个MyLayout布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyLayout extends LinearLayout &#123;</span><br><span class="line">    private ViewTarget&lt;MyLayout, Drawable&gt; viewTarget;</span><br><span class="line"></span><br><span class="line">    public MyLayout(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        viewTarget = new ViewTarget&lt;MyLayout, Drawable&gt;(this) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResourceReady(Drawable resource, Transition&lt;? super Drawable&gt; transition) &#123;</span><br><span class="line">                MyLayout myLayout = getView();</span><br><span class="line">                myLayout.setImageAsBackground(resource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewTarget&lt;MyLayout, Drawable&gt; getTarget() &#123;</span><br><span class="line">        return viewTarget;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setImageAsBackground(Drawable resource) &#123;</span><br><span class="line">        setBackground(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MyLayout的构造函数中，创建了一个ViewTarget的实例，并将Mylayout当前的实例this传了进去。ViewTarget中需要指定两个泛型，一个是View的类型，一个图片的类型（GlideDrawable或Bitmap）。然后在onResourceReady()方法中，就可以通过getView()方法获取到MyLayout的实例，并调用它的任意接口了。比如说这里我们调用了setImageAsBackground()方法来将加载出来的图片作为MyLayout布局的背景图。</p><p>2、使用ViewTarget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private String url = &quot;http://img.zcool.cn/community/0152ae56e6587c32f875520f7b9c52.jpg@1280w_1l_2o_100sh.jpg&quot;;</span><br><span class="line">private MyLayout myLayout;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    myLayout = findViewById(R.id.mylayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void loadImage(View view) &#123;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">         .load()</span><br><span class="line">         .into(myLayout.getTarget());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于MyLayout中已经提供了getTarget()接口，在into()方法中传入myLayout.getTarget()即可。效果如下图所示。 </p><center><br><img src="/assets/imgs/glide_06.gif" alt=""><br></center><h3><span id="preload方法">preload()方法</span></h3><p>假设一个需求场景：希望提前对图片进行一个预加载，等真正需要加载图片的时候就直接从缓存中读取，不用再等待慢长的网络加载时间。</p><p>通过之前的了解知道，如果在Target对象的onResourceReady()方法中做一个空实现，也就是不做任何逻辑处理，那么图片自然也就显示不出来了，而Glide的缓存机制却仍然还会正常工作，这样不就实现预加载功能。</p><p>虽然这样同样能实现，但是比较繁琐，Glide专门给我们提供了预加载的接口，也就是preload()方法，直接使用就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; preload(int width, int height) &#123;</span><br><span class="line">final PreloadTarget&lt;TranscodeType&gt; target = PreloadTarget.obtain(requestManager, width, height);</span><br><span class="line">return into(target);</span><br><span class="line">&#125;</span><br><span class="line">public Target&lt;TranscodeType&gt; preload() &#123;</span><br><span class="line">    return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preload()方法有两个方法重载，一个不带参数，表示将会加载图片的原始尺寸，另一个可以通过参数指定加载图片的宽和高。</p><p>preload()方法的用法也非常简单，直接使用它来替换into()方法即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .preload();</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用了preload()方法，最好要将diskCacheStrategy的缓存策略指定成DiskCacheStrategy.DATA。因为preload()方法默认是预加载的原始图片大小，而into()方法则默认会根据ImageView控件的大小来动态决定加载图片的大小。因此，如果不将diskCacheStrategy的缓存策略指定成DiskCacheStrategy.DATA的话，很容易会造成在预加载完成之后再使用into()方法加载图片，却仍然还是要从网络上去请求图片这种现象。</p><h3><span id="submit方法">submit()方法</span></h3><p>submit()方法和preload()方法类似，submit()方法也是可以替换into()方法的，这个方法只会下载图片，而不会对图片进行加载。当图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。</p><p>同样submit()方法有两个方法重载：</p><ul><li>submit()</li><li>submit(int width, int height)</li></ul><p>其中submit()方法是用于下载原始尺寸的图片，而submit(int width, int height)则可以指定下载图片的尺寸。</p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final Context context = getApplicationContext();</span><br><span class="line">            FutureTarget&lt;File&gt; target = Glide.with(context)</span><br><span class="line">                    .asFile()</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .submit();</span><br><span class="line">            final File imageFile = target.get();</span><br><span class="line">            runOnUiThread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    Toast.makeText(context, imageFile.getPath(), Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>调用submit()方法后会返回一个FutureTarget对象，然后Glide会在后台开始下载图片文件。通过调用FutureTarget的get()方法就可以获取下载好的图片文件。</p><p>如果此时图片还没有下载完，那么get()方法就会阻塞住，一直等到图片下载完成才会有值返回，所以submit()方法必须要用在子线程当中。</p><p>这里最好使用Application Context，这个时候不能再用Activity作为Context了，因为会有Activity销毁了但子线程还没执行完这种可能出现。</p><p>效果如下</p><center><br><img src="/assets/imgs/glide_07.gif" alt=""><br></center><h2><span id="监听">监听</span></h2><p>当需要判断图片是否加载完成，加载失败后怎么调试错误原因，这时需要设置listener()监听。 </p><h3><span id="listener">listener()</span></h3><p>基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(new MyGlideUrl(url, &quot;2&quot;))</span><br><span class="line">     .apply(options)</span><br><span class="line">     .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         @Override</span><br><span class="line">         public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p>listener()方法中实现了一个RequestListener的实例。其中RequestListener需要实现两个方法，一个onResourceReady()方法，一个onLoadFailed()方法。当图片加载完成的时候就会回调onResourceReady()方法，而当图片加载失败的时候就会回调onLoadFailed()方法，onLoadFailed()方法中会将失败的GlideException参数传进来，这样就可以定位具体失败的原因了。</p><p>onResourceReady()方法和onLoadFailed()方法都有一个布尔值的返回值，返回false就表示这个事件没有被处理，还会继续向下传递，返回true就表示这个事件已经被处理掉了，从而不会再继续向下传递。举个简单点的例子，如果在RequestListener的onResourceReady()方法中返回了true，那么就不会再回调Target的onResourceReady()方法了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回调&quot;&gt;&lt;a href=&quot;#回调&quot; class=&quot;headerlink&quot; title=&quot;回调&quot;&gt;&lt;/a&gt;回调&lt;/h2&gt;&lt;h3 id=&quot;关于Target&quot;&gt;&lt;a href=&quot;#关于Target&quot; class=&quot;headerlink&quot; title=&quot;关于Target&quot;&gt;&lt;/a&gt;关于Target&lt;/h3&gt;&lt;p&gt;在Glide中，Target 是介于请求和请求者之间的中介者的角色。Target 负责展示占位符，加载资源，并为每个请求决定合适的尺寸。被使用得最频繁的是 ImageViewTargets ，它用于在 ImageView 上展示占位符、Drawable 和 Bitmap 。用户还可以实现自己的 Target ，或者从任何可用的基类派生子类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Glide" scheme="https://vergofeng.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Glide使用1 基本用法</title>
    <link href="https://vergofeng.github.io/2017/09/20/Glide-v4%E4%BD%BF%E7%94%A81/"/>
    <id>https://vergofeng.github.io/2017/09/20/Glide-v4使用1/</id>
    <published>2017-09-19T16:00:00.000Z</published>
    <updated>2018-01-03T07:45:30.588Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="/assets/imgs/glide_logo.png" alt=""><br></center><h2><span id="简介">简介</span></h2><p>github：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></p><p>Glide是一款由Bump Technologies开发的图片加载框架，使得我们可以在Android平台上以极度简单的方式加载和展示图片。</p><p>目前，Glide最新的稳定版本是4.0.0</p><a id="more"></a><h2><span id="使用">使用</span></h2><h3><span id="gradle">Gradle</span></h3><p>在build.gradle(Module:XXX)添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.bumptech.glide:glide:4.0.0&apos;</span><br><span class="line">    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="基本用法">基本用法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(url).into(imageView);</span><br></pre></td></tr></table></figure><center><br><img src="/assets/imgs/glide_01.gif" alt=""><br></center><p>with()方法，用于创建一个加载图片的实例。with()方法可以接收Context、Activity或者Fragment类型的参数。</p><blockquote><p>注意：with()方法中传入的实例会决定Glide加载图片的生命周期，如果传入的是Activity或者Fragment的实例，那么当这个Activity或Fragment被销毁的时候，图片加载也会停止。如果传入的是ApplicationContext，那么只有当应用程序被杀掉的时候，图片加载才会停止。</p></blockquote><p>load()方法，用于指定待加载的图片资源。Glide支持加载各种各样的图片资源，包括网络图片、本地图片、应用资源、二进制流、Uri对象等等。其他用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 加载本地图片</span><br><span class="line">File file = new File(getExternalCacheDir() + &quot;/image.jpg&quot;);</span><br><span class="line">Glide.with(this).load(file).into(imageView);</span><br><span class="line"></span><br><span class="line">// 加载应用资源</span><br><span class="line">int resource = R.drawable.image;</span><br><span class="line">Glide.with(this).load(resource).into(imageView);</span><br><span class="line"></span><br><span class="line">// 加载二进制流</span><br><span class="line">byte[] image = getImageBytes();</span><br><span class="line">Glide.with(this).load(image).into(imageView);</span><br><span class="line"></span><br><span class="line">// 加载Uri对象</span><br><span class="line">Uri imageUri = getImageUri();</span><br><span class="line">Glide.with(this).load(imageUri).into(imageView);</span><br></pre></td></tr></table></figure><p>into()方法，用于指定显示图片的ImageView上。把这个ImageView的实例传进去就可以了，后续会列举into方法更丰富的用法。</p><h3><span id="占位图">占位图</span></h3><p>占位图有两种：加载占位图和异常占位图。</p><p>加载占位图是指在加载图片的等待时间内加载一张临时图片，等图片加载出来后再替换掉。</p><p>异常占位图是指在由于网络信号差等异常情况下，导致图片加载失败，加载异常占位图。</p><p>需要new RequestOptions对象，placeholder()设置加载占位图，error()设置异常占位图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .placeholder(R.drawable.loading) //加载占位图</span><br><span class="line">        .error(R.drawable.error);        //异常占位图</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><center><br><img src="/assets/imgs/glide_02.gif" alt=""><br></center><h3><span id="指定加载格式">指定加载格式</span></h3><p>使用Glide可以很方便的加载GIF图片，并不需要编写什么额外的代码，Glide内部会自动判断图片格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this) </span><br><span class="line">     .load(&quot;http://p1.pstatp.com/large/166200019850062839d3&quot;) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><center><br><img src="/assets/imgs/glide_03.gif" alt=""><br></center><p>所以不管我们传入的是一张普通图片，还是一张GIF图片，Glide都会自动进行判断，并且可以正确地把它解析并展示出来。</p><p>如果说希望加载的这张图必须是一张静态图片，不需要Glide自动判断它到底是静图还是GIF图。这s时需要指定加载格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this) </span><br><span class="line">     .asBitmap() </span><br><span class="line">     .load(&quot;http://p1.pstatp.com/large/166200019850062839d3&quot;) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p><code>asBitmap()</code>方法就是只允许加载静态图片，不需要Glide去自动进行图片格式的判断，当加载GIF图的时候，会加载GIF图的第一帧。</p><p>还有<code>asGif()</code>方法，用来强制指定加载动态图片。<code>asFile()</code>方法和<code>asDrawable()</code>方法，分别用于强制指定文件格式的加载和Drawable格式的加载。</p><h3><span id="指定图片大小">指定图片大小</span></h3><p>实际上，使用Glide在大多数情况下是不需要指定图片大小的，因为Glide会自动根据ImageView的大小来决定图片的大小，以此保证图片不会占用过多的内存从而引发OOM。</p><p>如果必须给图片指定一个固定的大小，可以使用RequestOptions类中的<code>override()</code>方法来指定加载图片的尺寸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .override(100, 100); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p>现在只Glide会将图片加载成 100 × 100 像素的尺寸，而不会管ImageView的大小是多少了。</p><p>如果想加载一张图片的原始尺寸的话，可以使用Target.SIZE_ORIGINAL关键字，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .override(Target.SIZE_ORIGINAL); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><p>这样的话，Glide就不会再去自动压缩图片，而是会去加载图片的原始尺寸。当然，这种写法也会面临着更高的OOM风险。</p><center><br><img src="/assets/imgs/glide_04.gif" alt=""><br></center><h3><span id="缓存">缓存</span></h3><p>Glide缓存有两个模块，一个是内存缓存，一个是硬盘缓存。这两种缓存模块相互结合才构成了Glide极佳的图片缓存效果。</p><h4><span id="内存缓存">内存缓存</span></h4><p>内存缓存的主要作用是防止应用重复将图片数据读取到内存当中。</p><p>Glide默认就是开启内存缓存的。当使用Glide加载了一张图片之后，这张图片就会被缓存到内存当中，只要在它还没从内存中被清除之前，下次使用Glide再加载这张图片都会直接从内存当中读取，而不用重新从网络或硬盘上读取了，这样就可以大幅度提升图片的加载效率。比如在一个RecyclerView当中反复上下滑动，RecyclerView中只要是Glide加载过的图片都可以直接从内存当中迅速读取并展示出来，从而大大提升了用户体验。</p><p>当然Glide也提供了禁用内存缓存方法，设置<code>skipMemoryCache()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .skipMemoryCache(true); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><h4><span id="磁盘缓存">磁盘缓存</span></h4><p>硬盘缓存的主要作用是防止应用重复从网络或其他地方重复下载和读取数据。</p><p>Glide通过设置<code>diskCacheStrategy()</code>，传入参数来设置磁盘缓存策略，Glide4.0之后提供了5种缓存策略：</p><ul><li>DiskCacheStrategy.NONE： 表示不缓存任何内容。</li><li>DiskCacheStrategy.DATA： 表示只缓存原始图片。</li><li>DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。</li><li>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</li><li>DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions() </span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.DATA); </span><br><span class="line">Glide.with(this) </span><br><span class="line">     .load(url) </span><br><span class="line">     .apply(options) </span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure><h4><span id="清除缓存">清除缓存</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//清除内存缓存，必须在主线程中执行</span><br><span class="line">Glide.get(context).clearMemory();</span><br><span class="line"></span><br><span class="line">//清除磁盘缓存，必须在子线程中执行</span><br><span class="line">new AsyncTask&lt;Void, Void, Void&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Void doInBackground(Void... params) &#123;</span><br><span class="line">        Glide.get(applicationContext).clearDiskCache();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="小结">小结</span></h2><p>以上就是关于Glide v4的基本用法，只是简单整理了相关使用方法，具体的介绍可以参考Glide官方的<a href="https://muyangmin.github.io/glide-docs-cn/" target="_blank" rel="noopener">中文文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;&lt;img src=&quot;/assets/imgs/glide_logo.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;github：&lt;a href=&quot;https://github.com/bumptech/glide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/bumptech/glide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Glide是一款由Bump Technologies开发的图片加载框架，使得我们可以在Android平台上以极度简单的方式加载和展示图片。&lt;/p&gt;
&lt;p&gt;目前，Glide最新的稳定版本是4.0.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="Glide" scheme="https://vergofeng.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio使用进阶</title>
    <link href="https://vergofeng.github.io/2016/11/22/Android-Studio%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
    <id>https://vergofeng.github.io/2016/11/22/Android-Studio使用进阶/</id>
    <published>2016-11-21T16:00:00.000Z</published>
    <updated>2017-12-18T10:33:27.924Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看徐医生出的第二本新书《Android群英传—神兵利器》，看到了第三章 “Android Studio 奇技淫巧”，由于书中所讲的一些快捷键等操作都是基于Mac的，所以这里我按照书中内容整理下在Windows下对应的快捷键。</p><h2><span id="操作与导航">操作与导航</span></h2><h4><span id="单词选择">单词选择</span></h4><p>通过”Ctrl + ← / →”来实现单词的光标移动。但是在Android编程中，开发者使用最多的是驼峰命名法。此时如果按单词来整体移动的话，那么在选择某些变量的一部分时就不是很方便。可以通过设置来开启”Use CamelHumps words”，就可以按照驼峰来移动光标选择了。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-9bf6e3cbaf6d26f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="实现按驼峰来移动光标"></p><a id="more"></a><h4><span id="显示最近操作-修改">显示最近操作、修改</span></h4><p>使用”Ctrl + E”快捷键来显示最近浏览过的文件，类似于浏览器的浏览记录。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-12989ae7f1982fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="Recent File"></p><p>使用”Ctri + Shift + E”快捷键来显示最近编辑过的文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-5f82eed962d4f399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="Recent Edited  Files"></p><p>使用”Ctrl + Tab”快捷键来进行各个界面的切换。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-f643f2ff3625551a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="窗口导航"></p><h4><span id="操作记录">操作记录</span></h4><p>Android Studio保存了每个操作的历史，通过”Ctrl + Alt + 左/右箭头”来进行访问位置的导航。<br>PS：这快捷键会与windows电脑的转屏快捷键冲突，我们可以自己修改Android Studio的快捷键，或者关闭电脑的转屏功能，这里附以下关闭电脑转屏快捷键的方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-7a6adb60ae5b119b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="关掉转屏"></p><h4><span id="移动行">移动行</span></h4><p>通过 “Alt + Shift + 上/下方向键” 来进行上下移动代码。  </p><h4><span id="查找调用">查找调用</span></h4><p>在开发中，我们常常需要查找一个方法在何处被调用，我们可以选中这个方法名单击鼠标右键，选择 “Find Usages”，或者通过 “Option + F7” 快捷键。</p><p> <img src="http://upload-images.jianshu.io/upload_images/680151-70175cc9fa877f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="Find Usages">  </p><h4><span id="快速方法操作">快速方法操作</span></h4><p>通过按住 “Ctrl” 键，并点击方法名，也可以通过 “Ctrl + B” 快捷键。</p><h4><span id="查找参数定义与文档">查找参数定义与文档</span></h4><p>通过 “Ctrl + P” 快捷键来查看方法的参数定义。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-1f758417e11c24c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看参数"></p><p>通过 “Ctrl + Q” 快捷键来查看文档详细</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-9d531c9a184c2dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="查看文档"></p><p>如果想要鼠标放上去就显示文档的提示，可以在设置中进行设置，如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-2c07cb9402b39f68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="文档悬浮提示"></p><h4><span id="多重选择">多重选择</span></h4><p>例如开发中，需要将好几个private修改为public，好几个int修改为float等，就可以使用多重选择功能。<br>1、将光标放在要修改的单词处，然后通过 “Alt + J” 来选中整个单词，再按一次 “Alt + J” 就可以选中第二个一样的单词，这样就可以一次性修改。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-6706d687ebc95e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多重选择"></p><p>2、按住 “Alt” 键并拖动鼠标，可以通过列进行多重选择。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-091266d470d18ab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列选择"></p><p>3、多光标编辑：通过 “Alt + Shift + 鼠标点击”，可以增加一个新的编辑光标，从而对多个地方同时进行修改。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-08b0f7aa20120e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多光标编辑"></p><h4><span id="快速完成">快速完成</span></h4><p>通过 “Ctrl + Shift + Enter” 可以快速完成某些操作。例如方法大括号的添加、行尾分号的添加、自动格式化该行等操作。</p><h4><span id="代码提示">代码提示</span></h4><p>Android Studio中默认的快捷键是 “Ctrl + Space”，但这个快捷键会与系统的切换输入法冲突，这里我是修改了默认的快捷键设置。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-1c7479299aa87a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="修改快捷键"></p><p><img src="http://upload-images.jianshu.io/upload_images/680151-6309501258f07310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="代码提示"></p><p>此外还提供了快捷键 “Ctrl + Shift + Space” 以显示更加智能的代码提示，可以根据上下文来获取更为丰富的代码提示。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-41b02944cde3cf22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="智能提示"></p><p>在程序出现错误的时候，可以通过 “Alt + Enter” 快捷键来获取代码修改提示。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-fef92e079728f7f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速修复"></p><h4><span id="查看大纲">查看大纲</span></h4><p>当前类如果代码量很大时，可以通过快捷键 “Ctrl + F12”，可以调出大纲界面，即显示方法和成员变量列表。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-ef83b964056ad66c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="查看大纲"></p><p>通过输入方法名，可以快速定位，也支持模糊查询，查询方法的一部分关键字也能进行筛选。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-2008a7ba04f2e9f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="大纲筛选"></p><h4><span id="书签">书签</span></h4><p>在平常阅读代码，分析代码思路的时候，经常需要记录一些关键的代码、方法。这时可以使用书签来记录，通过快捷键 “F11” 可以将一出代码添加到书签或者从书签中删除。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-9ba52f70cb12a0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="书签"></p><p>添加到书签的代码，在行数旁边会有一个小钩，同时在Favorite标签中，可以找到相应的Boomarks。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-f47bbcd851a2eaae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="显示书签"></p><p>另外，可以通过快捷键 “Shift + F11” 来调出书签面板，显示所有的书签。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-30cb297b610a18f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="显示所有书签"></p><h4><span id="其他操作技巧">其他操作技巧</span></h4><ul><li><p>代码折叠<br>通过 “Ctrl + -“ 对一段代码进行折叠。<br>通过 “Ctrl + +” 对一段代码进行展开。</p></li><li><p>预览方法定义<br>通过快捷键 “Ctrl + Shift + I” 在当前页面上对指定的方法进行预览。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/680151-634bd43d3bb32cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="预览方法定义"></p><ul><li>拆分窗口<br>默认情况下编辑界面只有一个界面，可以通过拆分窗口，同时展示更多的编辑界面，方便我们进行代码比较或者查看等等。设置方法如下图。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/680151-dcef335c60ae42a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="拆分窗口"></p><h2><span id="快速重构">快速重构</span></h2><h4><span id="重构入口">重构入口</span></h4><p>通过快捷键 “Ctrl + Shift + Alt + T” 可以打开这个重构入口。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-73e67d8dde8d8039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="重构入口"></p><p>或者通过鼠标右键，选择 “Refactor” 调出这个界面。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-46d4829aecdaf169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="重构选项"></p><h4><span id="extract-的妙用">Extract 的妙用</span></h4><p>在重构选项中，有Extratct选项，这在重构代码时非常有用。例如将一段重复的代码抽取出来作为一个方法，就可以如图操作。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-7e81f4eef7f82cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="提取方法"></p><p>选择Method，就可以将一段代码抽出作为一个方法，并且可以设置方法的访问类型。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-61ca1a8eba044141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="生成提取方法信息"></p><h4><span id="surround-with">Surround With</span></h4><p>在开发中，例如增加判空的if条件，或者是增加try catch捕获异常，可以使用快捷键 “Ctrl + Alt + T” 来进行操作。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-f849538553015e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="Surround With"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看徐医生出的第二本新书《Android群英传—神兵利器》，看到了第三章 “Android Studio 奇技淫巧”，由于书中所讲的一些快捷键等操作都是基于Mac的，所以这里我按照书中内容整理下在Windows下对应的快捷键。&lt;/p&gt;
&lt;h2 id=&quot;操作与导航&quot;&gt;&lt;a href=&quot;#操作与导航&quot; class=&quot;headerlink&quot; title=&quot;操作与导航&quot;&gt;&lt;/a&gt;操作与导航&lt;/h2&gt;&lt;h4 id=&quot;单词选择&quot;&gt;&lt;a href=&quot;#单词选择&quot; class=&quot;headerlink&quot; title=&quot;单词选择&quot;&gt;&lt;/a&gt;单词选择&lt;/h4&gt;&lt;p&gt;通过”Ctrl + ← / →”来实现单词的光标移动。但是在Android编程中，开发者使用最多的是驼峰命名法。此时如果按单词来整体移动的话，那么在选择某些变量的一部分时就不是很方便。可以通过设置来开启”Use CamelHumps words”，就可以按照驼峰来移动光标选择了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/680151-9bf6e3cbaf6d26f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480&quot; alt=&quot;实现按驼峰来移动光标&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android Studio" scheme="https://vergofeng.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>TabLayout的使用</title>
    <link href="https://vergofeng.github.io/2016/09/26/TabLayout/"/>
    <id>https://vergofeng.github.io/2016/09/26/TabLayout/</id>
    <published>2016-09-25T16:00:00.000Z</published>
    <updated>2017-12-18T10:37:58.725Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><blockquote><p>TabLayout provides a horizontal layout to display tabs.</p></blockquote><p>源码注释中表示，TabLayout是提供了一个水平的布局来展示标签。通常我们用来做选项卡这类效果。平常我们有用过开源库 PagerSlidingTabStrip 和 ViewPagerIndicator 来实现效果。</p><h2><span id="简单使用">简单使用</span></h2><h5><span id="1导入兼容包">1.导入兼容包</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:24.1.1&apos;</span><br></pre></td></tr></table></figure><h5><span id="2layout中添加">2.layout中添加</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.TabLayout</span><br><span class="line">android:id=&quot;@+id/tablayout&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h5><span id="3java中使用">3.java中使用</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@BindView(R.id.tablayout)</span><br><span class="line">TabLayout tabLayout;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;头条&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;社会&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;娱乐&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;体育&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;科技&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;财经&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java代码中，通过addTab()方法来添加选项，有4个重载方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-2d09ea4110d4ce7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="addTab()"></p><p>看过源码知道，不管使用哪一个方法，最终都会调用最后一个方法，参数最多的。<br>（1） Tab tab：就是Tab类实例。<br>（2） int position：指定添加的Tab插入的位置。<br>（3） boolean setSelected：指定添加的Tab是否为选中状态<br>关于Tab类的一些设置方法，下面会说明。</p><h5><span id="4效果">4.效果</span></h5><p><img src="http://upload-images.jianshu.io/upload_images/680151-4d32b42a63e33eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="TabLayout简单使用"></p><h2><span id="tablayout样式调整">TabLayout样式调整</span></h2><h5><span id="属性">属性</span></h5><p>在layout中添加的时候会发现有如下可设置的属性：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-94aaf4d50f04ab8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="TabLayout属性"></p><ul><li>tabBackground：设置整个TabLayout背景</li><li>tabIndicatorColor：设置指示器的颜色</li><li>tabIndicatorHeight：设置指示器的高度</li><li>tabTextColor：设置未选中项中的字体颜色</li><li>tabSelectedTextColor：设置选中项中的字体颜色</li><li>tabTextAppearance：设置style改变字体属性</li><li>tabMode：设置Tablayout的布局模式，有两个值<br>fixed：固定的，不能滑动，很多标签的时候会被挤压<br>scrollable：可以滑动的<br>默认是fixed</li><li>tabGravity：设置TabLayout的布局方式，有两个值<br>fill：充满<br>center：居中<br>默认是fill，且只有当tabMode为fixed时才有效</li><li>tabMaxWidth：设置tab项最大的宽度</li><li>tabMinWidth：设置tab项最小的宽度</li><li>tabContentStart：设置TabLayout开始位置的偏移量</li><li>paddingStart，paddingEnd：设置整个TabLayout的内边距</li><li>tabPadding，tabPaddingStart，tabPaddingEnd，tabPaddingTop，tabPaddingBottom：设置tab项的内边距</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.TabLayout</span><br><span class="line">    android:id=&quot;@+id/tablayout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:tabBackground=&quot;@color/colorPrimary&quot;</span><br><span class="line">    app:tabIndicatorColor=&quot;@android:color/white&quot;</span><br><span class="line">    app:tabIndicatorHeight=&quot;4dp&quot;</span><br><span class="line">    app:tabSelectedTextColor=&quot;#ffffffff&quot;</span><br><span class="line">    app:tabMode=&quot;scrollable&quot;</span><br><span class="line">    app:tabTextAppearance=&quot;@style/AppTheme.TabLayout.TextAppearance&quot;/&gt;</span><br></pre></td></tr></table></figure><h5><span id="style中添加样式">style中添加样式</span></h5><p>同样，我们可以在style中添加一个样式，给TabLayout设置style属性。</p><h6><span id="stylexml">style.xml</span></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme.TabLayout&quot; parent=&quot;Widget.Design.TabLayout&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;tabMode&quot;&gt;scrollable&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;tabIndicatorColor&quot;&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;tabIndicatorHeight&quot;&gt;4dp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;tabTextAppearance&quot;&gt;@style/AppTheme.TabLayout.TextAppearance&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;tabBackground&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;tabSelectedTextColor&quot;&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style name=&quot;AppTheme.TabLayout.TextAppearance&quot; parent=&quot;TextAppearance.Design.Tab&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textSize&quot;&gt;16sp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;#b2ffffff&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;textAllCaps&quot;&gt;false&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6><span id="layout">layout</span></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.TabLayout</span><br><span class="line">    android:id=&quot;@+id/tablayout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    style=&quot;@style/AppTheme.TabLayout&quot;/&gt;</span><br></pre></td></tr></table></figure><h5><span id="效果">效果</span></h5><p><img src="http://upload-images.jianshu.io/upload_images/680151-3b70fb0c42fd453d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="样式调整效果"></p><h2><span id="tab类">Tab类</span></h2><p>Tab类是TabLayout中的静态内部类，源码：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-38462c036839904a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="Tab静态内部类"></p><p>看源码知道Tab类的构造方法是私有的，不能直接new对象，注释也表明了使用方法，通过newTab()方法来创建实例。</p><p>Tab类的一些设置方法，看下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-5292133712995b4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="Tab相关设置方法"></p><ul><li>setContentDescription：设置tab标签内容描述</li><li>seCustomView：设置一个自定义view来显示标签</li><li>setIcon：给tab设置一个icon</li><li>setTag：给tab设置一个标签</li><li>setText：设置tab的文本内容</li></ul><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@BindView(R.id.tablayout)</span><br><span class="line">TabLayout tabLayout;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">    TabLayout.Tab tab1 = tabLayout.newTab();</span><br><span class="line">    tab1.setContentDescription(&quot;one&quot;);</span><br><span class="line">    tab1.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">    tab1.setText(&quot;头条&quot;);</span><br><span class="line">    tab1.setTag(1);</span><br><span class="line">    tabLayout.addTab(tab1);</span><br><span class="line"></span><br><span class="line">    //自定义view</span><br><span class="line">    View view = LayoutInflater.from(this).inflate(R.layout.custom_tab_layout, null);</span><br><span class="line">    ImageView iv_tab = (ImageView) view.findViewById(R.id.iv_tab);</span><br><span class="line">    TextView tv_tab = (TextView) view.findViewById(R.id.tv_tab);</span><br><span class="line">    iv_tab.setImageResource(R.mipmap.ic_launcher);</span><br><span class="line">    tv_tab.setText(&quot;社会&quot;);</span><br><span class="line">    TabLayout.Tab tab2 = tabLayout.newTab();</span><br><span class="line">    tab2.setCustomView(view);</span><br><span class="line">    tab2.setContentDescription(&quot;two&quot;);</span><br><span class="line">    tab2.setTag(2);</span><br><span class="line">    tabLayout.addTab(tab2);</span><br><span class="line"></span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;娱乐&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;体育&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;科技&quot;));</span><br><span class="line">    tabLayout.addTab(tabLayout.newTab().setText(&quot;财经&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义view的布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/iv_tab&quot;</span><br><span class="line">        android:layout_width=&quot;30dp&quot;</span><br><span class="line">        android:scaleType=&quot;fitXY&quot;</span><br><span class="line">        android:layout_height=&quot;30dp&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_tab&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textColor=&quot;#b2ffffff&quot;</span><br><span class="line">        android:layout_marginLeft=&quot;3dp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-c43994a2fb909cc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="Tab设置效果"></p><h2><span id="tablayoutviewpager">TabLayout+ViewPager</span></h2><p>使用TabLayout时，更多的是用场景是配合ViewPager一起使用，通过TabLayout的setupWithViewPager()方法，使两者关联起来。</p><p>示例：</p><h6><span id="layout布局">layout布局</span></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/main_toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;/&gt;</span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tablayout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        style=&quot;@style/AppTheme.TabLayout&quot;/&gt;</span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id=&quot;@+id/viewpager&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h6><span id="创建fragment">创建Fragment</span></h6><p>（1）布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/title_tv&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;&gt;</span><br><span class="line">    &lt;/TextView&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>（2）java类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class TabFragment extends Fragment &#123;</span><br><span class="line">    public static final String PAGE_TITLE = &quot;PAGE_TITLE&quot;;</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    public static TabFragment newInstance(String title) &#123;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putString(PAGE_TITLE, title);</span><br><span class="line">        TabFragment tabFragment = new TabFragment();</span><br><span class="line">        tabFragment.setArguments(bundle);</span><br><span class="line">        return tabFragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        title = getArguments().getString(PAGE_TITLE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_tab, container, false);</span><br><span class="line">        TextView titleTv = (TextView) view.findViewById(R.id.title_tv);</span><br><span class="line">        titleTv.setText(title);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6><span id="创建viewpager适配器">创建ViewPager适配器</span></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TabFragmentPagerAdapter extends FragmentPagerAdapter &#123;</span><br><span class="line">    private static final String[] mTitles = &#123;&quot;头条&quot;, &quot;社会&quot;, &quot;娱乐&quot;, &quot;体育&quot;, &quot;科技&quot;, &quot;财经&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public TabFragmentPagerAdapter(FragmentManager fm) &#123;</span><br><span class="line">        super(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Fragment getItem(int position) &#123;</span><br><span class="line">        return TabFragment.newInstance(mTitles[position]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return mTitles.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CharSequence getPageTitle(int position) &#123;</span><br><span class="line">        return mTitles[position];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6><span id="activity中关联">Activity中关联</span></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@BindView(R.id.tablayout)</span><br><span class="line">TabLayout tabLayout;</span><br><span class="line">@BindView(R.id.viewpager)</span><br><span class="line">ViewPager mViewPager;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">    TabFragmentPagerAdapter adapter = new TabFragmentPagerAdapter(getSupportFragmentManager());</span><br><span class="line">    mViewPager.setAdapter(adapter);</span><br><span class="line">    tabLayout.setupWithViewPager(mViewPager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6><span id="效果">效果</span></h6><p><img src="http://upload-images.jianshu.io/upload_images/680151-d117362be8911d88.gif?imageMogr2/auto-orient/strip" alt="TabLayout+ViewPager"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;TabLayout provides a horizontal layout to display tabs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码注释中表示，TabLayout是提供了一个水平的布局来展示标签。通常我们用来做选项卡这类效果。平常我们有用过开源库 PagerSlidingTabStrip 和 ViewPagerIndicator 来实现效果。&lt;/p&gt;
&lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h2&gt;&lt;h5 id=&quot;1-导入兼容包&quot;&gt;&lt;a href=&quot;#1-导入兼容包&quot; class=&quot;headerlink&quot; title=&quot;1.导入兼容包&quot;&gt;&lt;/a&gt;1.导入兼容包&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:design:24.1.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;2-layout中添加&quot;&gt;&lt;a href=&quot;#2-layout中添加&quot; class=&quot;headerlink&quot; title=&quot;2.layout中添加&quot;&gt;&lt;/a&gt;2.layout中添加&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;android.support.design.widget.TabLayout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	android:id=&amp;quot;@+id/tablayout&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	android:layout_height=&amp;quot;wrap_content&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://vergofeng.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>Navigation Drawer使用</title>
    <link href="https://vergofeng.github.io/2016/07/24/Navigation-Drawer%E4%BD%BF%E7%94%A8/"/>
    <id>https://vergofeng.github.io/2016/07/24/Navigation-Drawer使用/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2017-12-18T10:38:13.575Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Navigation Drawer是在 Material Design 中推出的一种侧滑导航菜单栏控件。包含两个部分，一部分是侧滑（DrawerLayout），一部分是导航菜单栏（NavigationView）。</p><h2><span id="as新建">AS新建</span></h2><p>利用Android Studio可以快速建立这个控件</p><ul><li>在新建项目时，在最后选择Navigation Drawer Activity</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/680151-51b206b1886deb77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="新建项目时"></p><a id="more"></a><ul><li>在新建Activity时，选择Navigation Drawer Activity</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/680151-ab9cee0b87ddcff7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="新建Activity时"></p><h2><span id="drawerlayout">DrawerLayout</span></h2><p>DrawerLayout布局中，由两部分组成，一部分是内容布局，一部分是侧滑菜单布局。其中侧滑菜单布局通过设置 “android:layout_gravity” 属性，来控制是左侧滑，还是右侧滑。参考实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.ui.MainActivity&quot;&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">        &lt;android.support.v7.widget.Toolbar</span><br><span class="line">            android:id=&quot;@+id/main_toolbar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">            android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">            app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/content_tv&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">            android:text=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;start&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:background=&quot;@android:color/white&quot;</span><br><span class="line">        android:text=&quot;导航菜单页左&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;end&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:background=&quot;@android:color/white&quot;</span><br><span class="line">        android:text=&quot;导航菜单页右&quot;/&gt;</span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><p>至此，侧滑效果就实现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-6964cee08db9e0e5.gif?imageMogr2/auto-orient/strip" alt="侧滑效果"></p><p>DrawerLayout中也有一些常会用到的方法，来控制例如打开、关闭菜单，监听滑动事件等，这里暂时列举一些，还是得多看api和源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//打开左侧菜单，同理右侧就是 GravityCompat.END</span><br><span class="line">drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">//关闭左侧菜单，同理右侧就是 GravityCompat.END</span><br><span class="line">drawerLayout.closeDrawer(GravityCompat.START);</span><br><span class="line">//设置抽屉打开时，剩余挡住内容区域部分的颜色</span><br><span class="line">drawerLayout.setScrimColor(Color.parseColor(&quot;#4cff0000&quot;));</span><br><span class="line">//设置抽屉锁定模式 LOCK_MODE_LOCKED_OPEN:锁定 无法滑动</span><br><span class="line">drawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN, GravityCompat.START);</span><br><span class="line">//监听滑动事件</span><br><span class="line">drawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onDrawerSlide(View drawerView, float slideOffset) &#123;</span><br><span class="line">        //抽屉滑动时回调</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDrawerOpened(View drawerView) &#123;</span><br><span class="line">        //抽屉打开后回调</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDrawerClosed(View drawerView) &#123;</span><br><span class="line">        //抽屉关闭后回调</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDrawerStateChanged(int newState) &#123;</span><br><span class="line">        //抽屉滑动状态改变时回调</span><br><span class="line">        switch (newState) &#123;</span><br><span class="line">            case DrawerLayout.STATE_DRAGGING:</span><br><span class="line">                //拖动状态</span><br><span class="line">                break;</span><br><span class="line">            case DrawerLayout.STATE_IDLE:</span><br><span class="line">                //静止状态</span><br><span class="line">                break;</span><br><span class="line">            case DrawerLayout.STATE_SETTLING:</span><br><span class="line">                //设置状态</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2><span id="navigationview">NavigationView</span></h2><p>NavigationView是兼容包中提供用来实现导航菜单控件。使用menu资源填充数据，可以更简单高效的实现导航菜单。</p><h5><span id="添加依赖">添加依赖</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:24.1.0&apos;</span><br></pre></td></tr></table></figure><h5><span id="布局中引用">布局中引用</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:id=&quot;@+id/drawerlayout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.ui.MainActivity&quot;&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">        &lt;android.support.v7.widget.Toolbar</span><br><span class="line">            android:id=&quot;@+id/main_toolbar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">            android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">            app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/content_tv&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">            android:text=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.NavigationView</span><br><span class="line">        android:id=&quot;@+id/navigation_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;start&quot;</span><br><span class="line">        app:headerLayout=&quot;@layout/navigation_drawer_header&quot;</span><br><span class="line">        app:menu=&quot;@menu/navigation_drawer_menu&quot;/&gt;</span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><p>NavigationView分为两部分，一部分是headerLayout，一部分是menu。headerLayout就是对应菜单的顶部部分，一般用来显示用户信息什么的，menu则对应实际的菜单选项。</p><h5><span id="定义headerlayout">定义headerLayout</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:background=&quot;@color/colorPrimary&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:layout_margin=&quot;10dp&quot;</span><br><span class="line">        android:text=&quot;HeaderLayout&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot; /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><h5><span id="定义menu">定义menu</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;group android:checkableBehavior=&quot;single&quot;&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item_dync&quot;</span><br><span class="line">            android:icon=&quot;@mipmap/ic_menu_dync_selected&quot;</span><br><span class="line">            android:title=&quot;首页&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item_explore&quot;</span><br><span class="line">            android:icon=&quot;@mipmap/ic_menu_explore_selected&quot;</span><br><span class="line">            android:title=&quot;发现&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item_message&quot;</span><br><span class="line">            android:icon=&quot;@mipmap/ic_menu_message_selected&quot;</span><br><span class="line">            android:title=&quot;消息&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item_person&quot;</span><br><span class="line">            android:icon=&quot;@mipmap/ic_menu_person_selected&quot;</span><br><span class="line">            android:title=&quot;我的&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;item android:title=&quot;其他&quot;&gt;</span><br><span class="line">        &lt;menu&gt;</span><br><span class="line">            &lt;item</span><br><span class="line">                android:id=&quot;@+id/subitem_01&quot;</span><br><span class="line">                android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">                android:title=&quot;分享&quot; /&gt;</span><br><span class="line">            &lt;item</span><br><span class="line">                android:id=&quot;@+id/subitem_02&quot;</span><br><span class="line">                android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">                android:title=&quot;设置&quot; /&gt;</span><br><span class="line">            &lt;item</span><br><span class="line">                android:id=&quot;@+id/subitem_03&quot;</span><br><span class="line">                android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">                android:title=&quot;反馈&quot; /&gt;</span><br><span class="line">        &lt;/menu&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p>这样NavigationView就添加成功，效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-123468088132f0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="NavigationView效果"></p><h5><span id="menu-item-的点击监听">Menu Item 的点击监听</span></h5><p>直接使用 NavigationView 的 setNavigationItemSelectedListener() 方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onNavigationItemSelected(MenuItem item) &#123;</span><br><span class="line">        int itemId = item.getItemId();</span><br><span class="line">        switch (itemId) &#123;</span><br><span class="line">            case R.id.item_dync:</span><br><span class="line">                break;</span><br><span class="line">            case R.id.item_explore:</span><br><span class="line">                break;</span><br><span class="line">            //......</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>Navigation Drawer的用法还是比较简单的，但是NavigationView的封装性太高，个人觉得不是特别实用，相对自己定义界面可能来的比较方便，或许是自己用的不到家。</p><p>关于抽屉效果，个人觉得目前而言随着手机的屏幕越来越大，导致用户操作起来不是很方便，现在主流的设计还是底部导航栏。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Navigation Drawer是在 Material Design 中推出的一种侧滑导航菜单栏控件。包含两个部分，一部分是侧滑（DrawerLayout），一部分是导航菜单栏（NavigationView）。&lt;/p&gt;
&lt;h2 id=&quot;AS新建&quot;&gt;&lt;a href=&quot;#AS新建&quot; class=&quot;headerlink&quot; title=&quot;AS新建&quot;&gt;&lt;/a&gt;AS新建&lt;/h2&gt;&lt;p&gt;利用Android Studio可以快速建立这个控件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在新建项目时，在最后选择Navigation Drawer Activity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/680151-51b206b1886deb77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640&quot; alt=&quot;新建项目时&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://vergofeng.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>Toolbar中添加菜单</title>
    <link href="https://vergofeng.github.io/2016/07/16/toolbar-1-2/"/>
    <id>https://vergofeng.github.io/2016/07/16/toolbar-1-2/</id>
    <published>2016-07-15T16:00:00.000Z</published>
    <updated>2017-12-18T10:37:29.400Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="回顾">回顾</span></h2><p>我的<a href="https://vergofeng.github.io/2016/07/15/toolbar_1-1/">《Toolbar使用》</a>这篇文章中写过，Toolbar有两种使用方式</p><ul><li>作为ActionBar来使用</li><li>作为独立的控件来使用。</li></ul><p>所以在Toolbar中添加菜单也有两种方式。</p><h2><span id="添加菜单">添加菜单</span></h2><h4><span id="新建菜单资源">新建菜单资源</span></h4><p>在res下新建menu文件夹用来存放菜单资源xml。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/toolbar_search&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_search&quot;</span><br><span class="line">        android:title=&quot;搜索&quot;</span><br><span class="line">        android:orderInCategory=&quot;0&quot;</span><br><span class="line">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class="line">        app:showAsAction=&quot;ifRoom|collapseActionView&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/toolbar_collection&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:orderInCategory=&quot;1&quot;</span><br><span class="line">        android:title=&quot;收藏&quot;</span><br><span class="line">        app:showAsAction=&quot;never&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/toolbar_share&quot;</span><br><span class="line">        android:orderInCategory=&quot;2&quot;</span><br><span class="line">        android:title=&quot;分享&quot;</span><br><span class="line">        app:showAsAction=&quot;never&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/toolbar_fontsize&quot;</span><br><span class="line">        android:orderInCategory=&quot;3&quot;</span><br><span class="line">        android:title=&quot;字号&quot;</span><br><span class="line">        app:showAsAction=&quot;never&quot; /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>orderInCategory<br>设置菜单项的排列顺序，必须设置大于等于0的整数值。数值小的排列在前，如果值相等，则按照xml中的顺序展现。</p></li><li><p>title<br>菜单项的标题。</p></li><li><p>icon<br>菜单项的图标。</p></li><li><p>showAsAction<br>该属性有五个值，可以混合使用。</p><ul><li><p>always<br>总是显示在Toolbar上。</p></li><li><p>ifRoom<br>如果Toolbar上还有空间，则显示，否则会隐藏在溢出列表中。</p></li><li><p>never<br>永远不会显示在Toolbar上，只会在溢出列表中出现。</p></li><li><p>withText<br>文字和图标一起显示。</p></li><li><p>collapseActionView<br>声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，这个操作视窗展开。一般要配合ifRoom一起使用才会有效。</p></li></ul></li></ul><h4><span id="activity中添加">Activity中添加</span></h4><h5><span id="toolbar作为actionbar使用">Toolbar作为ActionBar使用</span></h5><p>重写Activity的onCreateOptionsMenu方法并实现相关逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">    getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听菜单项的事件重写Activity的onOptionsItemSelected方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class="line">    switch (item.getItemId()) &#123;</span><br><span class="line">        case R.id.toolbar_collection:</span><br><span class="line">            Toast.makeText(this, &quot;收藏&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">        case R.id.toolbar_share:</span><br><span class="line">            Toast.makeText(this, &quot;分享&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">        case R.id.toolbar_fontsize:</span><br><span class="line">            Toast.makeText(this, &quot;字号&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">        case R.id.toolbar_model:</span><br><span class="line">            Toast.makeText(this, &quot;模式&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="toolbar作为独立控件使用">Toolbar作为独立控件使用</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolbar.inflateMenu(R.menu.menu_main);</span><br></pre></td></tr></table></figure><p>监听菜单项的事件则通过setOnMenuItemClickListener设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onMenuItemClick(MenuItem item) &#123;</span><br><span class="line">        switch (item.getItemId()) &#123;</span><br><span class="line">            case R.id.toolbar_collection:</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;收藏&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.toolbar_share:</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;分享&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.toolbar_fontsize:</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;字号&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.toolbar_model:</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;模式&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5><span id="效果">效果</span></h5><p><img src="http://upload-images.jianshu.io/upload_images/680151-92812d1fd1166a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="菜单效果"></p><h4><span id="弹出菜单样式调整">弹出菜单样式调整</span></h4><p>上面效果图会发现弹出的菜单是深灰色的背景，可能与当前页面风格不搭，Toolbar提供了setPopupTheme方法和对应的popupTheme属性来设置弹出菜单样式。</p><h5><span id="定义style样式资源">定义style样式资源</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot; &gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>该样式继承于ThemeOverlay.AppCompat.Light，我修改了文本色属性。</p><h5><span id="布局中设置">布局中设置</span></h5><p>这里通过popupTheme属性来修改样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/main_toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>要注意的是popupTheme并非Android本身SDK中的属性，而是来自于支持包，所以添加命名空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure><h5><span id="效果">效果</span></h5><p><img src="http://upload-images.jianshu.io/upload_images/680151-13e777b043af2665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="样式调整效果"></p><h2><span id="总结">总结</span></h2><p>关于Toolbar的使用以及样式调整就暂时整理到这，还有很多细节方面还得在实际运用中去积累。<br>最后贴张总的效果图</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-a298c6828384aec8.gif?imageMogr2/auto-orient/strip" alt="Toolbar"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;我的&lt;a href=&quot;https://vergofeng.github.io/2016/07/15/toolbar_1-1/&quot;&gt;《Toolbar使用》&lt;/a&gt;这篇文章中写过，Toolbar有两种使用方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为ActionBar来使用&lt;/li&gt;
&lt;li&gt;作为独立的控件来使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以在Toolbar中添加菜单也有两种方式。&lt;/p&gt;
&lt;h2 id=&quot;添加菜单&quot;&gt;&lt;a href=&quot;#添加菜单&quot; class=&quot;headerlink&quot; title=&quot;添加菜单&quot;&gt;&lt;/a&gt;添加菜单&lt;/h2&gt;&lt;h4 id=&quot;新建菜单资源&quot;&gt;&lt;a href=&quot;#新建菜单资源&quot; class=&quot;headerlink&quot; title=&quot;新建菜单资源&quot;&gt;&lt;/a&gt;新建菜单资源&lt;/h4&gt;&lt;p&gt;在res下新建menu文件夹用来存放菜单资源xml。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;menu xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:id=&amp;quot;@+id/toolbar_search&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:icon=&amp;quot;@mipmap/ic_search&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:title=&amp;quot;搜索&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:orderInCategory=&amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:actionViewClass=&amp;quot;android.support.v7.widget.SearchView&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:showAsAction=&amp;quot;ifRoom|collapseActionView&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:id=&amp;quot;@+id/toolbar_collection&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:orderInCategory=&amp;quot;1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:title=&amp;quot;收藏&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:showAsAction=&amp;quot;never&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:id=&amp;quot;@+id/toolbar_share&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:orderInCategory=&amp;quot;2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:title=&amp;quot;分享&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:showAsAction=&amp;quot;never&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:id=&amp;quot;@+id/toolbar_fontsize&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:orderInCategory=&amp;quot;3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:title=&amp;quot;字号&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:showAsAction=&amp;quot;never&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/menu&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://vergofeng.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>Toolbar的使用</title>
    <link href="https://vergofeng.github.io/2016/07/15/toolbar-1-1/"/>
    <id>https://vergofeng.github.io/2016/07/15/toolbar-1-1/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2017-12-18T10:37:39.608Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Toolbar是Android 5.0中引入的一个新控件。好比是ActionBar升级版，但是相比ActionBar，Toolbar变得更加自由，可以放到任何位置。</p><h2><span id="使用">使用</span></h2><p>由于我们平常开发app要兼容5.0以下的手机，所以使用Toolbar必须引用appcompat-v7兼容包，Android studio新建的工程默认是引用了appcompat-v7。</p><h4><span id="1布局">1.布局</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/main_toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h4><span id="2style样式设置">2.style样式设置</span></h4><p>使用Toolbar替代ActionBar，使用的主题必须是没有ActionBar的，否则会造成冲突。因此修改style.xml中主题样式，继承Theme.AppCompat.NoActionBar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4><span id="3activity中使用">3.Activity中使用</span></h4><h5><span id="1-将toolbar当作actionbar来使用">(1) 将Toolbar当作ActionBar来使用。</span></h5><p>这种情况一般发生在你想利用ActionBar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。</p><p>那么当前Activity需要继承AppCompatActivity，调用setSupportActionBar方法传入Toolbar的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    @BindView(R.id.main_toolbar)</span><br><span class="line">    Toolbar toolbar;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="2-将toolbar当作一个独立的控件来使用">(2) 将Toolbar当作一个独立的控件来使用。</span></h5><p>这种情况当前Activity可以不继承AppCompatActivity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    @BindView(R.id.main_toolbar)</span><br><span class="line">    Toolbar toolbar;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">        toolbar.setTitle(&quot;Example&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上步骤完成后，Toolbar就添加到了页面中。</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-5e96d463076f1272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="Toolbar效果"></p><h2><span id="toolbar配置">Toolbar配置</span></h2><p>Toolbar在ActionBar原有的设计基础上又将标题栏分为了多个区域，如下从Google找到的一张示例图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/680151-bd9c18ef97d737d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="配置"></p><p>大抵来说，配置常用的几个元素就如图中所示：</p><h5><span id="1-setnavigationicon">(1) setNavigationIcon</span></h5><p>设置导航按钮，比如作为返回按钮。<br>在Toolbar当作ActionBar来使用的情况下：<br>注意setNavigationIcon需要放在 setSupportActionBar之后才会生效。</p><p>可以使用ActionBar原有方法来添加一个系统的返回按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSupportActionBar().setDisplayHomeAsUpEnabled(true);</span><br></pre></td></tr></table></figure><p>可以通过setNavigationOnClickListener设置其点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.this, &quot;toolbar&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/680151-c9ce90440f4112ab.gif?imageMogr2/auto-orient/strip" alt="返回按钮"></p><h5><span id="2-setlogo">(2) setLogo</span></h5><p>设置图标（图中写错了，应该是setLogo）</p><h5><span id="3-settitle">(3) setTitle</span></h5><p>设置主标题。<br>在Toolbar当作ActionBar来使用的情况下：<br>setDisplayShowTitleEnabled需要设置为false，setTitle才能有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSupportActionBar().setDisplayShowTitleEnabled(false);</span><br></pre></td></tr></table></figure><h5><span id="4-setsubtitle">(4) setSubtitle</span></h5><p>设置副标题</p><h5><span id="5-setonmenuitemclicklistener">(5) setOnMenuItemClickListener</span></h5><p>设置菜单的点击事件，如果Toolbar当作ActionBar来使用的话，还可以直接在onOptionsItemSelected(MenuItem item)中设置。</p><h5><span id="测试代码如下">测试代码如下：</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toolbar.setNavigationIcon(R.mipmap.icon_back);</span><br><span class="line">toolbar.setLogo(R.mipmap.ic_launcher);</span><br><span class="line">toolbar.setTitle(&quot;Toolbar&quot;);</span><br><span class="line">toolbar.setSubtitle(&quot;subtitle&quot;);</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/680151-c43d0b4c4f834ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="配置效果"></p><h2><span id="总结">总结</span></h2><p>关于Toolbar的初步使用就这么多，在Toolbar当作ActionBar使用的情况下，能用ActionBar原有方法实现的功能尽量用其方法实现，不能实现的再考虑使用Toolbar的方法，举个例子，像菜单构建设置监听什么的，直接使用Activity提供的方法就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Toolbar是Android 5.0中引入的一个新控件。好比是ActionBar升级版，但是相比ActionBar，Toolbar变得更加自由，可以放到任何位置。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;由于我们平常开发app要兼容5.0以下的手机，所以使用Toolbar必须引用appcompat-v7兼容包，Android studio新建的工程默认是引用了appcompat-v7。&lt;/p&gt;
&lt;h4 id=&quot;1-布局&quot;&gt;&lt;a href=&quot;#1-布局&quot; class=&quot;headerlink&quot; title=&quot;1.布局&quot;&gt;&lt;/a&gt;1.布局&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;android.support.v7.widget.Toolbar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:id=&amp;quot;@+id/main_toolbar&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_height=&amp;quot;?attr/actionBarSize&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:background=&amp;quot;@color/colorPrimary&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
      <category term="Material Design" scheme="https://vergofeng.github.io/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的一点心得</title>
    <link href="https://vergofeng.github.io/2016/07/09/singleton-study/"/>
    <id>https://vergofeng.github.io/2016/07/09/singleton-study/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2017-12-18T07:29:53.205Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式算是设计模式中最容易理解的，最容易手写代码的设计模式。面试时也会常常会被问到用过什么设计模式时，最能脱口而出的就是单例模式了。</p><p>具体的定义优点什么的就不详述了，这里主要记录下我平常写单例及优化的一点心得。</p><h3><span id="懒汉式">懒汉式</span></h3><p>很多人包括我写单例的时候，第一想到的就是懒汉式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，而且是懒加载，只有调用getInstance方法是才会初始化。但是这样是线程不安全的，即当多个线程并行调用getInstance的时候，就会创建多个实例，不能正常工作。</p><a id="more"></a><p>所以这里就有了加锁方式，将整个getInstance方法设为同步，添加synchronized关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样简单粗暴的方式，虽然做到了线程安全，但导致了同一时间内只能有一个线程能够调用getInstance方法。</p><p>其实我们仅仅需要对初始化的代码进行同步，这就有了双重检验锁方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;              //第一次检查</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;      //第二次检查</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里第二次检查，是因为如果有多个线程同时执行完了第一次检查，这时如果同步块内不进行第二次检查的话，会生成多个实例了。</p><p>但是看了相关资料后，发现这样还是有点问题。引用资料中的介绍：</p><blockquote><p>由于instance = new Singleton()，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><p>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;              //第一次检查</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;      //第二次检查</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，这才是目前懒汉式单例最优的写法。</p><h3><span id="饿汉式">饿汉式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法最简单，而且是线程安全，但缺点是不是懒加载，类一旦加载到内存中就会初始化。在类的构造函数如果要传入参数的情况下，饿汉式是不适用的。</p><h3><span id="枚举单例">枚举单例</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        //TODO ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法最简单，利用枚举量来保证单例，同样是线程安全的，而且枚举解决了序列化和反射攻击。</p><h3><span id="总结">总结</span></h3><p>单例模式是运用频率很高的设计模式，其实在app中通常没有高并发的情况，所以选择哪种写法并不会产生多大的影响。但出于效率考虑，我推荐用懒汉式的使用双重校验锁方式，或者用枚举单例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式算是设计模式中最容易理解的，最容易手写代码的设计模式。面试时也会常常会被问到用过什么设计模式时，最能脱口而出的就是单例模式了。&lt;/p&gt;
&lt;p&gt;具体的定义优点什么的就不详述了，这里主要记录下我平常写单例及优化的一点心得。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式&quot;&gt;&lt;a href=&quot;#懒汉式&quot; class=&quot;headerlink&quot; title=&quot;懒汉式&quot;&gt;&lt;/a&gt;懒汉式&lt;/h3&gt;&lt;p&gt;很多人包括我写单例的时候，第一想到的就是懒汉式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private static Singleton instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton ()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static Singleton getInstance() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (instance == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		instance = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码很简单，而且是懒加载，只有调用getInstance方法是才会初始化。但是这样是线程不安全的，即当多个线程并行调用getInstance的时候，就会创建多个实例，不能正常工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vergofeng.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://vergofeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife基本使用</title>
    <link href="https://vergofeng.github.io/2016/07/08/ButterKnife%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://vergofeng.github.io/2016/07/08/ButterKnife基本使用/</id>
    <published>2016-07-07T16:00:00.000Z</published>
    <updated>2017-12-18T10:04:51.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/680151-a7950f3f81e1f520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="logo.png"></p><p>ButterKnife框架使用可以方便我们不用写大量的重复繁琐的findViewById和setOnClickListener等代码，它采用依赖注入的方式，通过注解的方式让view和代码中的对象绑定起来。</p><p>GitHub地址：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife</a></p><a id="more"></a><h2><span id="butterknife使用">ButterKnife使用</span></h2><h3><span id="添加依赖">添加依赖</span></h3><p>由于8.0.0之后的版本和之前的版本有差异，这里主要是8.1.0最新版本的添加方法，注意两个步骤都要完成：</p><h5><span id="1project的buildgradle中添加">1.Project的build.gradle中添加：</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123; </span><br><span class="line">classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="2app的buildgradle中添加">2.App的build.gradle中添加：</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.neenbedankt.android-apt&apos;</span><br><span class="line">    </span><br><span class="line">dependencies &#123;</span><br><span class="line">compile &apos;com.jakewharton:butterknife:8.1.0&apos;</span><br><span class="line">apt &apos;com.jakewharton:butterknife-compiler:8.1.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="activity中使用">Activity中使用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    @BindView(R.id.title_tv) TextView titleTv;</span><br><span class="line">    @BindView(R.id.back_btn) Button backBtn;</span><br><span class="line">    @BindView(R.id.logo_img) ImageView logoImg;</span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="activity中使用">Activity中使用</span></h3><p>注意：ButterKnife.bind(this)必须在setContentView之后。</p><h3><span id="fragment中使用">Fragment中使用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ListFragment extends Fragment&#123;</span><br><span class="line">    @BindView(R.id.title_tv) TextView titleTv;</span><br><span class="line">    @BindView(R.id.listview) ListView listView;</span><br><span class="line">    private Unbinder unbinder;</span><br><span class="line">    @Override </span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_list, container, false);</span><br><span class="line">        unbinder = ButterKnife.bind(this, view);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroyView() &#123;    </span><br><span class="line">        super.onDestroyView();    </span><br><span class="line">        unbinder.unbind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Fragment的生命周期不同于Activity，当在CreateView方法中绑定视图时，需要在onDestoryView中把对应的视图设置为null，这时需要解绑ButterKnife。</p><h3><span id="viewholder中使用">ViewHolder中使用</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class ViewHolder &#123;</span><br><span class="line">    @BindView(R.id.name_tv) TextView nameTv;</span><br><span class="line">    @BindView(R.id.content_tv) TextView contentTv;</span><br><span class="line">    @BindView(R.id.head_img) ImageView headImg;</span><br><span class="line"></span><br><span class="line">    public ViewHolder(View view) &#123;</span><br><span class="line">        ButterKnife.bind(this, view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="事件监听绑定">事件监听绑定</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//点击事件</span><br><span class="line">@OnClick(R.id.submit)</span><br><span class="line">public void buttonClick(Button button)&#123;</span><br><span class="line">    //TODO ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//listview item点击事件</span><br><span class="line">@OnItemClick(R.id.listview)</span><br><span class="line">public void itemClick(ListView listView)&#123;</span><br><span class="line">    //TODO ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多个控件具有相同的点击事件</span><br><span class="line">@OnClick(&#123; R.id.btn1, R.id.btn2, R.id.btn3 &#125;)</span><br><span class="line">public void buttonsClick(Button button)&#123;</span><br><span class="line">    //TODO ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：方法中的参数是可选的，但如果存在，必须是这个控件类或者控件类的父类。</p><h3><span id="资源绑定">资源绑定</span></h3><p>可以用@BindBool，@BindColor，@BindDimen，@BindDrawable，@BindInt和@BindString通过绑定R.bool以及其他对应id来进行资源的预定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BindString(R.string.title) String title; </span><br><span class="line">@BindDrawable(R.drawable.graphic) Drawable graphic; </span><br><span class="line">@BindColor(R.color.red) int red; </span><br><span class="line">@BindDimen(R.dimen.spacer) Float spacer;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>通过这种方式，就可以把资源直接赋值给变量，从而不再需要初始化。</p><h3><span id="可选绑定">可选绑定</span></h3><p>默认情况下，@bind和监听器绑定都必须有一个目标view，当butter knife找不到对应的view时会抛出一个异常。为了防止这种异常情况的发生，可以在绑定的字段前面使用@Nullable注解，在绑定的方法前面则可使用@Option注解，来表明对应的是一个可选绑定。</p><p>注：任何名为@Nullable第三方的注解都可以对字段起作用，这里推荐使用Android的”support-annotations“ library提供的@Nullable注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;</span><br><span class="line">@Optional @OnClick(R.id.maybe_missing) </span><br><span class="line">void onMaybeMissingClicked() &#123; </span><br><span class="line">// TODO ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="其他">其他</span></h3><p>butter knife也提供了一个findById方法，如果要在某些情况下查找某些子view，可以使用它来简化代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View view = LayoutInflater.from(context).inflate(R.layout.thing, null);</span><br><span class="line">TextView firstName = ButterKnife.findById(view, R.id.first_name);</span><br><span class="line">TextView lastName = ButterKnife.findById(view, R.id.last_name);</span><br></pre></td></tr></table></figure><h3><span id="混淆">混淆</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-keep class butterknife.** &#123; *; &#125;</span><br><span class="line">-dontwarn butterknife.internal.**</span><br><span class="line">-keep class **$$ViewBinder &#123; *; &#125;</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">  @butterknife.* &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">  @butterknife.* &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><p>官方文档：<a href="https://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">https://jakewharton.github.io/butterknife/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/680151-a7950f3f81e1f520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot; alt=&quot;logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;ButterKnife框架使用可以方便我们不用写大量的重复繁琐的findViewById和setOnClickListener等代码，它采用依赖注入的方式，通过注解的方式让view和代码中的对象绑定起来。&lt;/p&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JakeWharton/butterknife&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开源框架" scheme="https://vergofeng.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>App前后台运行状态判断</title>
    <link href="https://vergofeng.github.io/2016/07/08/App%E5%89%8D%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD/"/>
    <id>https://vergofeng.github.io/2016/07/08/App前后台运行状态判断/</id>
    <published>2016-07-07T16:00:00.000Z</published>
    <updated>2017-12-18T10:38:24.081Z</updated>
    
    <content type="html"><![CDATA[<p>经常在一些场景中，需要判断App是否在后台运行，从而做一些相应的处理。比如切换到后台运行后显示解锁界面等。接下来记录下平常用到的几种方法。</p><h3><span id="方法一">方法一</span></h3><p>利用ActivityManager，获取RuningAppProcessInfo或者RuningTaskInfo这两种方法，代码如下：<br>1、获取RuningAppProcessInfo</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAppForeground(Context context)&#123;</span><br><span class="line">    ActivityManager activityManager = (ActivityManager) context.getSystemService(Service.ACTIVITY_SERVICE);</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcessInfoList = activityManager.getRunningAppProcesses();</span><br><span class="line">    if (runningAppProcessInfoList==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (ActivityManager.RunningAppProcessInfo processInfo : runningAppProcessInfoList) &#123;</span><br><span class="line">        if (processInfo.processName.equals(context.getPackageName()) &amp;&amp;</span><br><span class="line">                processInfo.importance==ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、获取RuningTaskInfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public static boolean isAppForeground(Context context) &#123;</span><br><span class="line">    ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ComponentName cn = am.getRunningTasks(1).get(0).topActivity;</span><br><span class="line">    String currentPackageName = cn.getPackageName();</span><br><span class="line">    if(!TextUtils.isEmpty(currentPackageName) &amp;&amp; currentPackageName.equals(context.getPackageName())) &#123;</span><br><span class="line">        return true ;</span><br><span class="line">    &#125;</span><br><span class="line">    return false ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法有点类似于在使用windows的任务管理器，先抛开其性能方面的影响，这两种方法在，例如用户在进行应用间切换、按HOME键进入桌面、按开机键进入锁屏，都可能会影响到判断结果。而且获取RuningTaskInfo中getRunningTasks(1)方法在Android5.0中已经被废弃掉了，不推荐使用。</p><p>鉴于有一些问题的存在，这里推荐使用方法二。</p><h3><span id="方法二">方法二</span></h3><p>先上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">    public int count = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStopped(Activity activity) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                if (count == 0) &#123;</span><br><span class="line">                    Log.v(&quot;vergo&quot;, &quot;**********切到后台**********&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStarted(Activity activity) &#123;</span><br><span class="line">                if (count == 0) &#123;</span><br><span class="line">                    Log.v(&quot;vergo&quot;, &quot;**********切到前台**********&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityResumed(Activity activity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityPaused(Activity activity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityDestroyed(Activity activity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android在SDK 14的时候提供了ActivityLifecycleCallbacks接口，可以通过这个它拿到App所有Activity的生命周期回调。</p><p>通过重写Application的onCreate()方法，或者在Application的无参构造方法内，调用registerActivityLifecycleCallbacks()方法，并实现ActivityLifecycleCallbacks接口。</p><p>分析：<br>首先简单回顾下Activity的生命周期，如果Activity调用了onResume()，那么这个Activity肯定是可见的，也就是运行在前台的。如果调用了onPause()，且没有Activity来调用onResume()，那么App就在后台运行。</p><p>根据这个原理，我们可以定义一个计数变量count初始为0，在ActivityLifecycleCallbacks回调的onActivityResumed()方法中加一，在onActivityPaused()方法中减一，如果count等于1，表示App在前台，如果count等于0，则表示在后台。</p><p>但是很快就会发现，如果在onActivityResumed()和onActivityPaused()中进行计数，会有个延时，导致判断不准确。</p><p>又回到Activity的生命周期中来，比如从Activity A跳转至Activity B，A和B的生命周期变化经历了如下的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A onPause ——&gt; B onCreate ——&gt; B onStart ——&gt; B onResume ——&gt; A onStop</span><br></pre></td></tr></table></figure><p>可以看出，在A onPause到B onResume之间，根据我们对count的判断，表示在此短暂的阶段应用处于后台运行状态，这样逻辑肯定是不正确的。</p><p>所以，正确的方式应该在ActivityLifecycleCallbacks回调的onActivityStarted()方法里面对count加一，在onActivityStopped()方法里减一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常在一些场景中，需要判断App是否在后台运行，从而做一些相应的处理。比如切换到后台运行后显示解锁界面等。接下来记录下平常用到的几种方法。&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h3&gt;&lt;p&gt;利用ActivityManager，获取RuningAppProcessInfo或者RuningTaskInfo这两种方法，代码如下：&lt;br&gt;1、获取RuningAppProcessInfo&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://vergofeng.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
